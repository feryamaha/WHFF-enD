[
    {
      "conceptId": "typescript",
      "arrayId": "array-typescript-intro",
      "posts": [
        {
          "id": "1",
          "title": "O que é TypeScript?",
          "content1": "TypeScript é JavaScript com sintaxe para tipos. É uma linguagem de programação fortemente tipada que se baseia em JavaScript, oferecendo melhores ferramentas em qualquer escala. Desenvolvido pela Microsoft, o TypeScript foi projetado para desenvolvimento de aplicações de grande escala.",
          "content2": "O TypeScript adiciona sintaxe adicional ao JavaScript para suportar uma integração mais estreita com seu editor, permitindo capturar erros precocemente durante o desenvolvimento. O código TypeScript é convertido para JavaScript, que pode ser executado em qualquer lugar onde o JavaScript é executado: navegador, Node.js, Deno, Bun e em seus aplicativos.",
          "content3": "Uma das principais vantagens do TypeScript é sua capacidade de entender JavaScript e usar inferência de tipos para fornecer ótimas ferramentas sem código adicional. Você pode adotar TypeScript gradualmente, cada passo melhora o suporte do editor e aprimora sua base de código.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/intro.html",
          "code": [
            {
              "description": "Exemplo 1: Tipagem básica em TypeScript",
              "javascript": "// Tipagem de variáveis\nlet nome: string = 'João';\nlet idade: number = 25;\nlet ativo: boolean = true;\n\n// Tipagem de arrays\nlet numeros: number[] = [1, 2, 3, 4, 5];\nlet nomes: string[] = ['Ana', 'João', 'Maria'];\n\n// Tipagem de objetos\ninterface Pessoa {\n  nome: string;\n  idade: number;\n}\n\nlet pessoa: Pessoa = {\n  nome: 'João',\n  idade: 25\n};"
            },
            {
              "description": "Exemplo 2: Funções tipadas",
              "javascript": "// Função com tipos\nfunction somar(a: number, b: number): number {\n  return a + b;\n}\n\n// Arrow function com tipos\nconst multiplicar = (x: number, y: number): number => x * y;\n\n// Função com parâmetros opcionais\nfunction saudar(nome: string, sobrenome?: string): string {\n  return sobrenome ? `Olá, ${nome} ${sobrenome}!` : `Olá, ${nome}!`;\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "types",
      "arrayId": "array-typescript-types",
      "posts": [
        {
          "id": "2",
          "title": "Tipos Básicos em TypeScript",
          "content1": "O TypeScript oferece um sistema de tipos rico que inclui interfaces, tipos união, genéricos e muito mais. Os tipos básicos incluem: string, number, boolean, array, tuple, enum, any, void, null, undefined e object. O sistema de tipos permite que você descreva a forma dos objetos e funções em seu código.",
          "content2": "O TypeScript usa inferência de tipos para fornecer ótimas ferramentas sem código adicional. Quando você declara uma variável com um valor inicial, o TypeScript usa esse valor para determinar seu tipo. Isso torna o código mais conciso enquanto mantém a segurança dos tipos.",
          "content3": "Uma característica poderosa do TypeScript é a capacidade de definir tipos personalizados usando interfaces e tipos união. Isso permite que você crie contratos claros em seu código e capture erros em tempo de compilação.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/basic-types.html",
          "code": [
            {
              "description": "Exemplo 1: Tipos básicos e inferência",
              "javascript": "// Tipos básicos\nlet texto: string = 'Hello';\nlet numero: number = 42;\nlet booleano: boolean = true;\n\n// Inferência de tipos\nlet inferidoString = 'Mundo'; // tipo: string\nlet inferidoNumero = 123; // tipo: number\n\n// Arrays\nlet numeros: number[] = [1, 2, 3];\nlet textos: Array<string> = ['a', 'b', 'c'];\n\n// Tuple\nlet tupla: [string, number] = ['hello', 10];"
            },
            {
              "description": "Exemplo 2: Tipos união e tipos personalizados",
              "javascript": "// Tipo união\ntype ID = string | number;\nlet userId: ID = 123;\nuserId = 'abc123'; // também válido\n\n// Tipo personalizado\ntype Ponto = {\n  x: number;\n  y: number;\n};\n\nlet coordenada: Ponto = { x: 10, y: 20 };\n\n// Enum\nenum DirecaoCardinal {\n  Norte,\n  Sul,\n  Leste,\n  Oeste\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "interfaces",
      "arrayId": "array-typescript-interfaces",
      "posts": [
        {
          "id": "3",
          "title": "Interfaces em TypeScript",
          "content1": "Interfaces são uma forma fundamental de definir contratos em seu código e descrever a forma dos objetos. Elas permitem que você defina tipos nomeados que descrevem a estrutura dos objetos, incluindo propriedades, métodos e tipos indexados.",
          "content2": "Uma das características mais poderosas das interfaces no TypeScript é a capacidade de estender outras interfaces, permitindo que você combine e reutilize definições de tipos. Interfaces também podem ser usadas para descrever funções e podem incluir propriedades opcionais e somente leitura.",
          "content3": "As interfaces são puramente uma construção em tempo de compilação e não geram nenhum código JavaScript. Elas são usadas apenas para verificação de tipos durante o desenvolvimento.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/interfaces.html",
          "code": [
            {
              "description": "Exemplo 1: Interfaces básicas e herança",
              "javascript": "// Interface básica\ninterface Usuario {\n  nome: string;\n  email: string;\n  idade?: number; // Propriedade opcional\n  readonly id: number; // Propriedade somente leitura\n}\n\n// Herança de interface\ninterface Funcionario extends Usuario {\n  cargo: string;\n  salario: number;\n}\n\n// Implementando as interfaces\nconst usuario: Usuario = {\n  id: 1,\n  nome: 'João',\n  email: 'joao@email.com'\n};"
            },
            {
              "description": "Exemplo 2: Interfaces para funções e classes",
              "javascript": "// Interface para função\ninterface Calculadora {\n  (x: number, y: number): number;\n}\n\n// Interface para classe\ninterface Animal {\n  nome: string;\n  fazerSom(): void;\n}\n\nclass Cachorro implements Animal {\n  constructor(public nome: string) {}\n\n  fazerSom() {\n    console.log('Au au!');\n  }\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "classes",
      "arrayId": "array-typescript-classes",
      "posts": [
        {
          "id": "4",
          "title": "Classes em TypeScript",
          "content1": "Classes em TypeScript fornecem uma maneira orientada a objetos de criar objetos reutilizáveis. O TypeScript oferece suporte total a recursos de orientação a objetos como herança, modificadores de acesso (public, private, protected), métodos estáticos e abstratos.",
          "content2": "O TypeScript adiciona tipos e anotações às classes do JavaScript, tornando-as mais robustas e seguras. Os modificadores de acesso ajudam a controlar a visibilidade dos membros da classe, enquanto as propriedades readonly garantem que os valores não possam ser modificados após a inicialização.",
          "content3": "Classes abstratas e interfaces trabalham juntas para criar hierarquias de tipos flexíveis e reutilizáveis. O TypeScript também suporta getters/setters e membros estáticos, permitindo um design orientado a objetos mais sofisticado.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/classes.html",
          "code": [
            {
              "description": "Exemplo 1: Classes básicas e herança",
              "javascript": "class Animal {\n  protected nome: string;\n\n  constructor(nome: string) {\n    this.nome = nome;\n  }\n\n  public fazerSom(): void {\n    console.log('Som genérico');\n  }\n}\n\nclass Gato extends Animal {\n  private idade: number;\n\n  constructor(nome: string, idade: number) {\n    super(nome);\n    this.idade = idade;\n  }\n\n  public fazerSom(): void {\n    console.log('Miau!');\n  }\n}"
            },
            {
              "description": "Exemplo 2: Classes abstratas e interfaces",
              "javascript": "abstract class Forma {\n  abstract calcularArea(): number;\n\n  mostrarArea(): void {\n    console.log(`Área: ${this.calcularArea()}`);\n  }\n}\n\nclass Retangulo extends Forma {\n  constructor(private largura: number, private altura: number) {\n    super();\n  }\n\n  calcularArea(): number {\n    return this.largura * this.altura;\n  }\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "functions",
      "arrayId": "array-typescript-functions",
      "posts": [
        {
          "id": "5",
          "title": "Funções em TypeScript",
          "content1": "Funções em TypeScript adicionam tipos aos parâmetros e valores de retorno, tornando as assinaturas de função mais claras e seguras. O TypeScript suporta tanto funções nomeadas quanto funções anônimas, com tipagem opcional e parâmetros padrão.",
          "content2": "O TypeScript introduz conceitos como sobrecarga de função, que permite definir múltiplas assinaturas de tipo para a mesma função. Parâmetros opcionais e rest parameters também são suportados, oferecendo maior flexibilidade na definição de funções.",
          "content3": "As funções podem ser tipadas usando interfaces ou tipos, e o TypeScript oferece inferência de tipo de retorno. Isso ajuda a garantir que as funções sejam usadas corretamente e retornem os tipos esperados.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/functions.html",
          "code": [
            {
              "description": "Exemplo 1: Funções básicas e tipos",
              "javascript": "// Função com tipos\nfunction somar(a: number, b: number): number {\n  return a + b;\n}\n\n// Função com parâmetro opcional\nfunction saudar(nome: string, titulo?: string): string {\n  return titulo ? `${titulo} ${nome}` : `Olá ${nome}`;\n}\n\n// Arrow function com tipos\nconst multiplicar = (x: number, y: number): number => x * y;"
            },
            {
              "description": "Exemplo 2: Sobrecarga de funções",
              "javascript": "// Sobrecarga de função\nfunction processar(x: number): number;\nfunction processar(x: string): string;\nfunction processar(x: any): any {\n  if (typeof x === 'number') {\n    return x * 2;\n  } else {\n    return x.toUpperCase();\n  }\n}\n\n// Rest parameters\nfunction somarTodos(...numeros: number[]): number {\n  return numeros.reduce((total, n) => total + n, 0);\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "generics",
      "arrayId": "array-typescript-generics",
      "posts": [
        {
          "id": "6",
          "title": "Genéricos em TypeScript",
          "content1": "Genéricos são uma das características mais poderosas do TypeScript, permitindo criar componentes reutilizáveis que podem trabalhar com vários tipos. Eles fornecem uma maneira de fazer componentes que podem trabalhar com qualquer tipo de dado, mantendo a segurança de tipos.",
          "content2": "Com genéricos, você pode escrever funções, classes e interfaces que são reutilizáveis e tipadas de forma segura. Os genéricos permitem que você defina restrições de tipo, garantindo que apenas tipos específicos possam ser usados com seu componente genérico.",
          "content3": "O TypeScript inclui vários tipos genéricos integrados como Array<T>, Promise<T>, e Map<K,V>. Você também pode criar seus próprios tipos genéricos para criar código mais flexível e reutilizável.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/generics.html",
          "code": [
            {
              "description": "Exemplo 1: Funções genéricas",
              "javascript": "// Função genérica\nfunction identidade<T>(arg: T): T {\n  return arg;\n}\n\n// Uso da função genérica\nlet num = identidade<number>(42);\nlet str = identidade<string>('Hello');\n\n// Array genérico\nfunction primeiroElemento<T>(arr: T[]): T | undefined {\n  return arr[0];\n}"
            },
            {
              "description": "Exemplo 2: Classes e interfaces genéricas",
              "javascript": "// Interface genérica\ninterface Pair<T, U> {\n  primeiro: T;\n  segundo: U;\n}\n\n// Classe genérica\nclass Colecao<T> {\n  private itens: T[] = [];\n\n  adicionar(item: T): void {\n    this.itens.push(item);\n  }\n\n  obter(index: number): T {\n    return this.itens[index];\n  }\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "advanced-types",
      "arrayId": "array-typescript-advanced-types",
      "posts": [
        {
          "id": "7",
          "title": "Tipos Avançados em TypeScript",
          "content1": "O TypeScript oferece recursos avançados de tipagem que permitem criar tipos mais complexos e expressivos. Isso inclui tipos de união e interseção, tipos condicionais, tipos mapeados e utilitários de tipos integrados.",
          "content2": "Os tipos de união (|) e interseção (&) permitem combinar tipos existentes de diferentes maneiras. Tipos condicionais (T extends U ? X : Y) permitem selecionar tipos com base em condições, enquanto tipos mapeados permitem transformar tipos existentes em novos tipos.",
          "content3": "O TypeScript também fornece utilitários de tipos integrados como Partial<T>, Readonly<T>, Record<K,V>, e Pick<T,K> que ajudam a manipular e transformar tipos de maneira segura e eficiente.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/advanced-types.html",
          "code": [
            {
              "description": "Exemplo 1: Tipos de união e interseção",
              "javascript": "// Tipo de união\ntype ResultadoOperacao = Sucesso | Erro;\n\ninterface Sucesso {\n  sucesso: true;\n  dados: any;\n}\n\ninterface Erro {\n  sucesso: false;\n  mensagem: string;\n}\n\n// Tipo de interseção\ntype Admin = Usuario & {\n  privilegios: string[];\n  nivel: number;\n};"
            },
            {
              "description": "Exemplo 2: Tipos condicionais e mapeados",
              "javascript": "// Tipo condicional\ntype EhString<T> = T extends string ? true : false;\n\n// Tipo mapeado\ntype Opcional<T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Usando utilitários de tipos\ntype Usuario = {\n  nome: string;\n  idade: number;\n  email: string;\n};\n\ntype UsuarioReadonly = Readonly<Usuario>;\ntype UsuarioParcial = Partial<Usuario>;"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "decorators",
      "arrayId": "array-typescript-decorators",
      "posts": [
        {
          "id": "8",
          "title": "Decoradores em TypeScript",
          "content1": "Decoradores são uma característica experimental do TypeScript que permite adicionar anotações e metaprogramação às suas classes e membros de classe. Eles são amplamente utilizados em frameworks como Angular e podem ser aplicados a classes, métodos, acessadores, propriedades e parâmetros.",
          "content2": "Os decoradores são funções que podem modificar ou aumentar o comportamento de uma classe ou seus membros. Eles são executados em tempo de definição da classe e podem ser usados para adicionar metadados, validação, logging, ou modificar o comportamento original.",
          "content3": "TypeScript suporta vários tipos de decoradores: decoradores de classe, método, propriedade, acessador e parâmetro. Cada tipo de decorador recebe argumentos específicos que permitem acessar e modificar o elemento decorado.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/decorators.html",
          "code": [
            {
              "description": "Exemplo 1: Decoradores de classe e método",
              "javascript": "// Decorador de classe\nfunction Logger(target: Function) {\n  console.log(`Classe ${target.name} foi criada`);\n}\n\n// Decorador de método\nfunction Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const metodoOriginal = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Chamando ${propertyKey} com:`, args);\n    return metodoOriginal.apply(this, args);\n  };\n}\n\n@Logger\nclass Exemplo {\n  @Log\n  metodo(x: number) {\n    return x * 2;\n  }\n}"
            },
            {
              "description": "Exemplo 2: Decoradores de propriedade",
              "javascript": "// Decorador de propriedade\nfunction ValidarTamanho(min: number, max: number) {\n  return function(target: any, propertyKey: string) {\n    let valor: string;\n    \n    const getter = function() {\n      return valor;\n    };\n    \n    const setter = function(novoValor: string) {\n      if (novoValor.length < min || novoValor.length > max) {\n        throw new Error(`${propertyKey} deve ter entre ${min} e ${max} caracteres`);\n      }\n      valor = novoValor;\n    };\n    \n    Object.defineProperty(target, propertyKey, {\n      get: getter,\n      set: setter\n    });\n  };\n}\n\nclass Usuario {\n  @ValidarTamanho(3, 10)\n  nome: string;\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "modules",
      "arrayId": "array-typescript-modules",
      "posts": [
        {
          "id": "9",
          "title": "Módulos em TypeScript",
          "content1": "Módulos em TypeScript fornecem uma maneira de organizar e compartilhar código entre diferentes arquivos e projetos. O TypeScript suporta tanto módulos ES6 quanto CommonJS, permitindo importar e exportar tipos, interfaces, classes e valores.",
          "content2": "O sistema de módulos do TypeScript permite encapsular código, evitar poluição do namespace global e criar uma estrutura de código mais organizada. Você pode usar exportações nomeadas ou padrão, e importar elementos específicos ou módulos inteiros.",
          "content3": "O TypeScript também oferece recursos avançados de módulos como re-exportação, importação de tipos, importação dinâmica e resolução de módulos personalizada através do arquivo tsconfig.json.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/modules.html",
          "code": [
            {
              "description": "Exemplo 1: Exportações e importações básicas",
              "javascript": "// matematica.ts\nexport interface Calculadora {\n  somar(a: number, b: number): number;\n  subtrair(a: number, b: number): number;\n}\n\nexport class CalculadoraBasica implements Calculadora {\n  somar(a: number, b: number): number {\n    return a + b;\n  }\n\n  subtrair(a: number, b: number): number {\n    return a - b;\n  }\n}\n\n// app.ts\nimport { Calculadora, CalculadoraBasica } from './matematica';\n\nconst calc = new CalculadoraBasica();\nconsole.log(calc.somar(5, 3));"
            },
            {
              "description": "Exemplo 2: Re-exportação e importação de tipos",
              "javascript": "// tipos.ts\nexport type ID = string | number;\nexport interface Usuario {\n  id: ID;\n  nome: string;\n}\n\n// index.ts\nexport * from './tipos';\nexport * from './matematica';\n\n// utils.ts\nimport type { Usuario } from './tipos';\nimport { CalculadoraBasica as Calc } from './matematica';\n\nfunction processarUsuario(usuario: Usuario) {\n  console.log(`Processando usuário: ${usuario.nome}`);\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "enums",
      "arrayId": "array-typescript-enums",
      "posts": [
        {
          "id": "10",
          "title": "Enums em TypeScript",
          "content1": "Enums são uma característica do TypeScript que permite definir um conjunto de constantes nomeadas. Eles são especialmente úteis quando você tem um conjunto de valores relacionados que podem ser um número ou string, como direções, status ou configurações.",
          "content2": "O TypeScript suporta enums numéricos e de string. Por padrão, enums numéricos são auto-incrementados, começando do 0, mas você pode definir valores personalizados. Enums de string precisam ter seus valores explicitamente definidos.",
          "content3": "Enums também podem ser usados como tipos e oferecem recursos como enums constantes, enums computados e enums ambientes. Uma característica importante é que eles são preservados em tempo de execução, ao contrário de muitos outros recursos do TypeScript.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/enums.html",
          "code": [
            {
              "description": "Exemplo 1: Enums numéricos e de string",
              "javascript": "// Enum numérico\nenum DirecaoCardinal {\n  Norte,     // 0\n  Sul,       // 1\n  Leste,     // 2\n  Oeste      // 3\n}\n\n// Enum com valores personalizados\nenum StatusHttp {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500\n}\n\n// Enum de string\nenum TipoUsuario {\n  Admin = 'ADMIN',\n  Usuario = 'USER',\n  Convidado = 'GUEST'\n}"
            },
            {
              "description": "Exemplo 2: Enums constantes e computados",
              "javascript": "// Enum constante\nconst enum Dias {\n  Domingo,\n  Segunda,\n  Terca,\n  Quarta,\n  Quinta,\n  Sexta,\n  Sabado\n}\n\n// Enum computado\nenum FileAccess {\n  None,\n  Read = 1 << 1,      // 2\n  Write = 1 << 2,     // 4\n  ReadWrite = Read | Write,  // 6\n  // Valor computado\n  G = '123'.length\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "type-inference",
      "arrayId": "array-typescript-type-inference",
      "posts": [
        {
          "id": "11",
          "title": "Inferência de Tipos em TypeScript",
          "content1": "A inferência de tipos é um dos recursos mais poderosos do TypeScript, permitindo que o compilador deduza automaticamente os tipos com base no contexto do código. Isso reduz a necessidade de anotações de tipo explícitas enquanto mantém a segurança de tipos.",
          "content2": "O TypeScript usa inferência de tipos em várias situações, incluindo inicialização de variáveis, definição de parâmetros padrão, retornos de função e em expressões mais complexas como união de tipos e tipos genéricos.",
          "content3": "A inferência de tipos também funciona em contextos mais avançados, como em tipos condicionais e mapeados. O TypeScript pode inferir tipos em objetos aninhados, arrays, promessas e muito mais, tornando o código mais limpo e fácil de manter.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
          "code": [
            {
              "description": "Exemplo 1: Inferência básica de tipos",
              "javascript": "// Inferência em variáveis\nlet texto = 'Hello';  // inferido como string\nlet numero = 42;      // inferido como number\nlet booleano = true;  // inferido como boolean\n\n// Inferência em arrays\nlet numeros = [1, 2, 3];  // inferido como number[]\nlet mix = [1, 'dois'];    // inferido como (string | number)[]\n\n// Inferência em objetos\nlet pessoa = {\n  nome: 'João',\n  idade: 25,\n  ativo: true\n};  // Tipos das propriedades são inferidos"
            },
            {
              "description": "Exemplo 2: Inferência em funções e contextos mais complexos",
              "javascript": "// Inferência em funções\nfunction criarArray<T>(item: T, quantidade: number) {\n  return new Array<T>(quantidade).fill(item);\n}\n\n// O tipo é inferido com base no argumento\nlet numeros = criarArray(42, 3);     // number[]\nlet textos = criarArray('olá', 2);   // string[]\n\n// Inferência em promessas\nasync function getData() {\n  const response = await fetch('api/data');\n  const data = await response.json();  // Tipo inferido da resposta\n  return data;\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "type-assertions",
      "arrayId": "array-typescript-type-assertions",
      "posts": [
        {
          "id": "12",
          "title": "Type Assertions em TypeScript",
          "content1": "Type assertions (asserções de tipo) são uma maneira de informar ao compilador TypeScript que você sabe mais sobre o tipo de um valor do que ele pode inferir. É como dizer ao compilador 'confie em mim, eu sei o que estou fazendo'.",
          "content2": "Existem duas sintaxes para type assertions: a sintaxe com angle-bracket (<>) e a sintaxe as. A sintaxe as é preferida quando trabalhando com JSX/TSX. Type assertions não são conversões de tipo em tempo de execução; elas são removidas durante a compilação.",
          "content3": "É importante usar type assertions com cuidado, pois elas podem contornar a verificação de tipo do TypeScript. Em vez de usar type assertions, é geralmente melhor usar type guards ou declarações de tipo apropriadas quando possível.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions",
          "code": [
            {
              "description": "Exemplo 1: Sintaxes de type assertion",
              "javascript": "// Usando angle-bracket syntax\nlet algumValor: any = 'string';\nlet tamanho: number = (<string>algumValor).length;\n\n// Usando 'as' syntax (preferida)\nlet outroValor: any = 'string';\nlet comprimento: number = (outroValor as string).length;\n\n// Type assertion em objetos\ninterface Usuario {\n  nome: string;\n  idade: number;\n}\n\nlet dados = {};\nlet usuario = dados as Usuario;  // Asserting empty object as Usuario"
            },
            {
              "description": "Exemplo 2: Type assertions com type guards",
              "javascript": "// Type assertion com type guard\nfunction processarValor(valor: any) {\n  if (typeof valor === 'string') {\n    // Type guard - mais seguro que type assertion\n    console.log(valor.toUpperCase());\n  } else {\n    // Type assertion quando necessário\n    console.log((valor as number).toFixed(2));\n  }\n}\n\n// Double assertion (casos especiais)\nlet input = 'texto' as unknown as number;\n\n// Assertion em DOM\nconst elemento = document.getElementById('meuInput') as HTMLInputElement;\nconsole.log(elemento.value);  // Agora TypeScript sabe que é um input"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "union-types",
      "arrayId": "array-typescript-union-types",
      "posts": [
        {
          "id": "13",
          "title": "Union Types em TypeScript",
          "content1": "Union Types permitem que uma variável aceite mais de um tipo de dado. São criados usando o operador | (pipe) entre os tipos. Isso é particularmente útil quando um valor pode ser de diferentes tipos, como uma string ou um número.",
          "content2": "Ao trabalhar com union types, você pode usar type guards para determinar qual tipo específico está sendo usado em um determinado momento. Isso permite que você trabalhe com segurança com as propriedades e métodos específicos de cada tipo.",
          "content3": "Union types podem ser combinados com outros recursos do TypeScript, como interfaces e tipos genéricos, para criar tipos mais complexos e flexíveis. Eles são frequentemente usados em APIs que podem retornar diferentes tipos de resposta.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types",
          "code": [
            {
              "description": "Exemplo 1: Union types básicos",
              "javascript": "// Union type simples\ntype StringOrNumber = string | number;\n\nfunction processarValor(valor: StringOrNumber) {\n  if (typeof valor === 'string') {\n    return valor.toUpperCase();\n  } else {\n    return valor.toFixed(2);\n  }\n}\n\n// Union com tipos mais complexos\ntype ResultadoOperacao = {\n  sucesso: true;\n  valor: number;\n} | {\n  sucesso: false;\n  erro: string;\n};"
            },
            {
              "description": "Exemplo 2: Union types com interfaces e arrays",
              "javascript": "// Union types com interfaces\ninterface Gato {\n  tipo: 'gato';\n  miar(): void;\n}\n\ninterface Cachorro {\n  tipo: 'cachorro';\n  latir(): void;\n}\n\ntype Animal = Gato | Cachorro;\n\nfunction fazerBarulho(animal: Animal) {\n  switch (animal.tipo) {\n    case 'gato':\n      animal.miar();  // TypeScript sabe que é um Gato\n      break;\n    case 'cachorro':\n      animal.latir(); // TypeScript sabe que é um Cachorro\n      break;\n  }\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "intersection-types",
      "arrayId": "array-typescript-intersection-types",
      "posts": [
        {
          "id": "14",
          "title": "Intersection Types em TypeScript",
          "content1": "Intersection Types permitem combinar múltiplos tipos em um único tipo que inclui todas as características dos tipos combinados. São criados usando o operador & (e comercial) entre os tipos. Isso é útil quando você precisa que um objeto tenha todas as propriedades de múltiplos tipos.",
          "content2": "Diferente dos union types, que permitem que um valor seja de um tipo OU outro, intersection types exigem que o valor tenha TODAS as características dos tipos combinados. Isso é particularmente útil para mixins e outros padrões que combinam funcionalidades.",
          "content3": "Intersection types podem ser usados com interfaces, type aliases e outros tipos do TypeScript. Eles são uma ferramenta poderosa para criar tipos complexos que herdam características de múltiplos tipos base.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types",
          "code": [
            {
              "description": "Exemplo 1: Intersection types básicos",
              "javascript": "// Tipos base\ntype PessoaBase = {\n  nome: string;\n  idade: number;\n};\n\ntype Habilidades = {\n  programar: boolean;\n  linguagens: string[];\n};\n\n// Intersection type\ntype Desenvolvedor = PessoaBase & Habilidades;\n\nconst dev: Desenvolvedor = {\n  nome: 'Ana',\n  idade: 25,\n  programar: true,\n  linguagens: ['TypeScript', 'JavaScript']\n};"
            },
            {
              "description": "Exemplo 2: Intersection types com interfaces e funções",
              "javascript": "// Interfaces para intersection\ninterface Autenticavel {\n  login: string;\n  senha: string;\n  autenticar(): boolean;\n}\n\ninterface Identificavel {\n  id: number;\n  tipo: string;\n}\n\n// Usando intersection type em uma função\nfunction criarUsuarioAdmin(info: Autenticavel & Identificavel) {\n  return {\n    ...info,\n    permissoes: ['admin'],\n    verificarAcesso() {\n      return this.autenticar() && this.tipo === 'admin';\n    }\n  };\n}\n\nconst admin = criarUsuarioAdmin({\n  id: 1,\n  tipo: 'admin',\n  login: 'admin',\n  senha: '123456',\n  autenticar() { return true; }\n});"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "type-aliases",
      "arrayId": "array-typescript-type-aliases",
      "posts": [
        {
          "id": "15",
          "title": "Type Aliases em TypeScript",
          "content1": "Type Aliases (apelidos de tipo) permitem criar um novo nome para um tipo. Eles podem ser usados para criar nomes mais descritivos para tipos complexos, simplificar a sintaxe de tipos union e intersection, e tornar o código mais legível e manutenível.",
          "content2": "Type aliases podem referenciar a si mesmos e outros type aliases, permitindo a criação de tipos recursivos e complexos. Eles são particularmente úteis para definir tipos union e intersection, bem como para criar tipos utilitários reutilizáveis.",
          "content3": "Diferente das interfaces, type aliases não podem ser estendidos ou implementados. No entanto, eles oferecem mais flexibilidade na definição de tipos, podendo representar primitivos, unions, tuples e outros tipos mais complexos.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases",
          "code": [
            {
              "description": "Exemplo 1: Type aliases básicos",
              "javascript": "// Type alias simples\ntype Email = string;\ntype ID = string | number;\ntype Coordenada = [number, number];\n\n// Type alias com objeto\ntype Usuario = {\n  id: ID;\n  nome: string;\n  email: Email;\n  coordenadas: Coordenada;\n};\n\n// Type alias com union type\ntype Resultado<T> = {\n  sucesso: true;\n  dados: T;\n} | {\n  sucesso: false;\n  erro: string;\n};"
            },
            {
              "description": "Exemplo 2: Type aliases avançados",
              "javascript": "// Type alias recursivo\ntype ListaEncadeada<T> = {\n  valor: T;\n  proximo: ListaEncadeada<T> | null;\n};\n\n// Type alias com template literal\ntype Direcao = 'norte' | 'sul' | 'leste' | 'oeste';\ntype Movimento = `mover_${Direcao}`;\n\n// Type alias com mapped types\ntype Opcional<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype Usuario = {\n  nome: string;\n  idade: number;\n};\n\n// Torna todas as propriedades opcionais\ntype UsuarioOpcional = Opcional<Usuario>;"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "utility-types",
      "arrayId": "array-typescript-utility-types",
      "posts": [
        {
          "id": "16",
          "title": "Utility Types em TypeScript",
          "content1": "Utility Types são tipos integrados no TypeScript que facilitam transformações comuns de tipos. Eles fornecem uma maneira conveniente de modificar tipos existentes para criar novos tipos com características específicas.",
          "content2": "Os utility types mais comuns incluem Partial<T>, Readonly<T>, Record<K,V>, Pick<T,K>, Omit<T,K>, Exclude<T,U>, Extract<T,U>, NonNullable<T>, ReturnType<T>, InstanceType<T> e muitos outros. Cada um serve a um propósito específico na manipulação de tipos.",
          "content3": "Esses tipos utilitários são especialmente úteis ao trabalhar com APIs, manipulação de estado em aplicações React, e em qualquer situação onde você precisa transformar ou adaptar tipos existentes de maneira segura.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
          "code": [
            {
              "description": "Exemplo 1: Utility types básicos",
              "javascript": "interface Usuario {\n  id: number;\n  nome: string;\n  email: string;\n  senha: string;\n}\n\n// Partial - torna todas as propriedades opcionais\ntype UsuarioAtualizar = Partial<Usuario>;\n\n// Pick - seleciona apenas algumas propriedades\ntype UsuarioPublico = Pick<Usuario, 'id' | 'nome'>;\n\n// Readonly - torna todas as propriedades somente leitura\ntype UsuarioImutavel = Readonly<Usuario>;\n\n// Record - cria um tipo com chaves e valores específicos\ntype Permissoes = Record<'ler' | 'escrever' | 'deletar', boolean>;"
            },
            {
              "description": "Exemplo 2: Utility types avançados",
              "javascript": "// Exclude - remove tipos de uma união\ntype Primitivos = string | number | boolean | null;\ntype SemNull = Exclude<Primitivos, null>;\n\n// Extract - extrai tipos específicos de uma união\ntype Numerico = Extract<Primitivos, number | null>;\n\n// ReturnType - obtém o tipo de retorno de uma função\nfunction criarUsuario(nome: string, email: string): Usuario {\n  return { id: 1, nome, email, senha: '123' };\n}\ntype NovoUsuario = ReturnType<typeof criarUsuario>;\n\n// NonNullable - remove null e undefined do tipo\ntype EmailValido = NonNullable<string | null | undefined>;"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "namespaces",
      "arrayId": "array-typescript-namespaces",
      "posts": [
        {
          "id": "17",
          "title": "Namespaces em TypeScript",
          "content1": "Namespaces são uma forma de organizar código em TypeScript, criando um escopo nomeado para evitar colisões de nomes. Embora módulos sejam a forma preferida de organizar código em aplicações modernas, namespaces ainda são úteis em certos cenários.",
          "content2": "Namespaces podem ser aninhados e divididos em múltiplos arquivos. Eles são particularmente úteis quando você precisa encapsular código relacionado e evitar poluição do escopo global, especialmente em aplicações que não usam um sistema de módulos.",
          "content3": "Para usar membros de um namespace em outro arquivo, você precisa exportá-los explicitamente e referenciar o arquivo usando a diretiva /// <reference path='...' />. Em aplicações modernas, é recomendado usar módulos ES6 em vez de namespaces.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
          "code": [
            {
              "description": "Exemplo 1: Namespace básico",
              "javascript": "namespace Validacao {\n  export interface StringValidator {\n    validar(s: string): boolean;\n  }\n\n  export class RegexValidator implements StringValidator {\n    constructor(private regex: RegExp) {}\n\n    validar(s: string): boolean {\n      return this.regex.test(s);\n    }\n  }\n\n  export const emailRegex = /^[^@]+@[^@]+\\.[^@]+$/;\n  export const telefoneRegex = /^\\d{10,11}$/;\n}"
            },
            {
              "description": "Exemplo 2: Namespaces aninhados e referências",
              "javascript": "// validadores.ts\nnamespace App.Validadores {\n  export class EmailValidator {\n    static validar(email: string): boolean {\n      return /^[^@]+@[^@]+\\.[^@]+$/.test(email);\n    }\n  }\n\n  export namespace Interno {\n    export function validarFormato(valor: string, formato: RegExp): boolean {\n      return formato.test(valor);\n    }\n  }\n}\n\n// app.ts\n/// <reference path='validadores.ts' />\nlet email = 'teste@exemplo.com';\nif (App.Validadores.EmailValidator.validar(email)) {\n  console.log('Email válido');\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "async-await",
      "arrayId": "array-typescript-async-await",
      "posts": [
        {
          "id": "18",
          "title": "Async/Await em TypeScript",
          "content1": "TypeScript oferece suporte completo para async/await, permitindo escrever código assíncrono de forma mais limpa e legível. O TypeScript adiciona tipagem estática para promessas e funções assíncronas, tornando o código mais seguro e fácil de manter.",
          "content2": "Funções async sempre retornam uma Promise, e o TypeScript pode inferir corretamente o tipo do valor resolvido. O operador await só pode ser usado dentro de funções async e pausa a execução até que a Promise seja resolvida, tornando o código assíncrono parecer síncrono.",
          "content3": "O TypeScript também fornece tipos úteis para trabalhar com Promises, como Promise<T>, PromiseLike<T>, e permite criar tipos personalizados para valores assíncronos. O tratamento de erros em código assíncrono pode ser feito usando try/catch ou encadeamento de .catch().",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html#async-functions",
          "code": [
            {
              "description": "Exemplo 1: Funções async/await básicas",
              "javascript": "interface Usuario {\n  id: number;\n  nome: string;\n  email: string;\n}\n\nasync function buscarUsuario(id: number): Promise<Usuario> {\n  const response = await fetch(`/api/usuarios/${id}`);\n  if (!response.ok) {\n    throw new Error('Usuário não encontrado');\n  }\n  return response.json();\n}\n\nasync function exibirUsuario(id: number): Promise<void> {\n  try {\n    const usuario = await buscarUsuario(id);\n    console.log(`Usuário: ${usuario.nome}`);\n  } catch (erro) {\n    console.error('Erro:', erro.message);\n  }\n}"
            },
            {
              "description": "Exemplo 2: Promises paralelas e tratamento de erros",
              "javascript": "// Executando múltiplas promises em paralelo\nasync function buscarDados(): Promise<[Usuario[], Pedido[]]> {\n  try {\n    const [usuarios, pedidos] = await Promise.all([\n      fetch('/api/usuarios').then(r => r.json()),\n      fetch('/api/pedidos').then(r => r.json())\n    ]);\n    return [usuarios, pedidos];\n  } catch (erro) {\n    console.error('Erro ao buscar dados:', erro);\n    throw erro;\n  }\n}\n\n// Função assíncrona com tipo de retorno personalizado\ntype ResultadoAsync<T> = {\n  dados: T;\n  timestamp: number;\n};\n\nasync function buscarComMetadados<T>(\n  promise: Promise<T>\n): Promise<ResultadoAsync<T>> {\n  const dados = await promise;\n  return {\n    dados,\n    timestamp: Date.now()\n  };\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "error-handling",
      "arrayId": "array-typescript-error-handling",
      "posts": [
        {
          "id": "19",
          "title": "Tratamento de Erros em TypeScript",
          "content1": "TypeScript fornece recursos avançados para tratamento de erros, incluindo tipos específicos para erros, union types para resultados de erro, e integração com o sistema de tipos para garantir que erros sejam tratados adequadamente.",
          "content2": "Além do tradicional try/catch do JavaScript, o TypeScript permite criar tipos personalizados para erros, usar discriminated unions para tratamento de erro tipo-seguro, e aproveitar o sistema de tipos para garantir que todos os casos de erro sejam tratados.",
          "content3": "Boas práticas de tratamento de erro em TypeScript incluem criar classes de erro personalizadas, usar tipos de resultado que podem conter erro ou sucesso, e aproveitar o type narrowing para garantir tratamento adequado de diferentes tipos de erro.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/error-handling.html",
          "code": [
            {
              "description": "Exemplo 1: Classes de erro personalizadas e tipos de resultado",
              "javascript": "// Classes de erro personalizadas\nclass APIError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public code: string\n  ) {\n    super(message);\n    this.name = 'APIError';\n  }\n}\n\n// Tipo de resultado com erro\ntype Result<T, E = Error> = {\n  success: true;\n  data: T;\n} | {\n  success: false;\n  error: E;\n};\n\nasync function buscarDados(): Promise<Result<Usuario[]>> {\n  try {\n    const response = await fetch('/api/usuarios');\n    if (!response.ok) {\n      throw new APIError('Falha ao buscar usuários', response.status, 'API_ERROR');\n    }\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return { success: false, error };\n  }\n}"
            },
            {
              "description": "Exemplo 2: Type narrowing e tratamento de erros",
              "javascript": "// Type guard para erros\nfunction isAPIError(error: unknown): error is APIError {\n  return error instanceof APIError;\n}\n\n// Tratamento de erro com type narrowing\nasync function processarDados() {\n  const resultado = await buscarDados();\n\n  if (!resultado.success) {\n    if (isAPIError(resultado.error)) {\n      console.error(\n        `Erro de API: ${resultado.error.message} ` +\n        `(${resultado.error.statusCode})`\n      );\n    } else {\n      console.error('Erro desconhecido:', resultado.error);\n    }\n    return;\n  }\n\n  // TypeScript sabe que resultado.data é Usuario[]\n  const usuarios = resultado.data;\n  usuarios.forEach(usuario => console.log(usuario.nome));\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "config",
      "arrayId": "array-typescript-config",
      "posts": [
        {
          "id": "20",
          "title": "Configuração do TypeScript",
          "content1": "A configuração do TypeScript é gerenciada através do arquivo tsconfig.json, que define como o compilador TypeScript deve processar os arquivos. Este arquivo permite configurar opções de compilação, diretórios de entrada/saída, e várias outras configurações que afetam como o TypeScript funciona no seu projeto.",
          "content2": "Algumas das configurações mais importantes incluem strict (para habilitar verificações de tipo mais rigorosas), target (versão do JavaScript de saída), module (sistema de módulos), e outDir (diretório de saída). O TypeScript também suporta configurações para paths de aliases, decorators, e muito mais.",
          "content3": "O arquivo tsconfig.json também permite estender outras configurações usando extends, definir quais arquivos incluir/excluir da compilação, e configurar o comportamento do editor através de configurações específicas do IDE.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
          "code": [
            {
              "description": "Exemplo 1: Configuração básica do tsconfig.json",
              "javascript": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}"
            },
            {
              "description": "Exemplo 2: Configurações avançadas",
              "javascript": "{\n  \"compilerOptions\": {\n    // Configurações de path alias\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@components/*\": [\"src/components/*\"],\n      \"@utils/*\": [\"src/utils/*\"]\n    },\n    \n    // Configurações de decorators\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \n    // Configurações de tipo\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitAny\": true,\n    \n    // Configurações de módulo\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true\n  },\n  \"extends\": \"./tsconfig.base.json\"\n}"
            }
          ]
        }
      ]
    },
    {
      "conceptId": "best-practices",
      "arrayId": "array-typescript-best-practices",
      "posts": [
        {
          "id": "21",
          "title": "Melhores Práticas em TypeScript",
          "content1": "As melhores práticas em TypeScript incluem usar tipos estritos, evitar any quando possível, aproveitar a inferência de tipos, e criar interfaces/tipos bem definidos. É importante manter um equilíbrio entre segurança de tipos e complexidade do código.",
          "content2": "Algumas práticas recomendadas incluem: usar interfaces para definir contratos, preferir type quando precisar de unions ou tipos utilitários, usar enums para conjuntos fixos de valores, e aproveitar generics para criar código reutilizável e tipo-seguro.",
          "content3": "Também é importante configurar e usar ferramentas como ESLint com regras TypeScript, manter as dependências atualizadas, usar paths aliases para importações mais limpas, e documentar adequadamente tipos complexos usando JSDoc quando necessário.",
          "docUrl": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
          "code": [
            {
              "description": "Exemplo 1: Boas práticas de tipagem",
              "javascript": "// Use interfaces para contratos públicos\ninterface Usuario {\n  readonly id: number;  // Propriedades imutáveis\n  nome: string;\n  email: string;\n  idade?: number;  // Propriedades opcionais explícitas\n}\n\n// Use type para unions e intersections\ntype ResultadoOperacao<T> = {\n  sucesso: true;\n  dados: T;\n} | {\n  sucesso: false;\n  erro: string;\n};\n\n// Use generics para código reutilizável\nfunction primeiro<T>(array: T[]): T | undefined {\n  return array[0];\n}\n\n// Use type guards personalizados\nfunction isUsuario(obj: unknown): obj is Usuario {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'id' in obj &&\n    'nome' in obj &&\n    'email' in obj\n  );\n}"
            },
            {
              "description": "Exemplo 2: Padrões e práticas avançadas",
              "javascript": "// Use discriminated unions\ntype Estado =\n  | { tipo: 'carregando' }\n  | { tipo: 'sucesso'; dados: Usuario[] }\n  | { tipo: 'erro'; mensagem: string };\n\n// Documentação com JSDoc\n/**\n * Processa uma lista de usuários e retorna estatísticas\n * @param usuarios - Array de usuários para processar\n * @returns Objeto com estatísticas dos usuários\n * @throws {Error} Se a lista estiver vazia\n */\nfunction processarUsuarios(usuarios: Usuario[]): {\n  total: number;\n  ativos: number;\n  idade: { min: number; max: number; media: number };\n} {\n  // Implementação...\n}\n\n// Use const assertions para literais\nconst config = {\n  api: {\n    url: 'https://api.exemplo.com',\n    timeout: 5000\n  }\n} as const;\n\n// Use barrel exports\n// index.ts\nexport * from './usuario';\nexport * from './autenticacao';\nexport * from './validacao';"
            }
          ]
        }
      ]
    }
]
