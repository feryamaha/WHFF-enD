[
  {
    "conceptId": "javascript",
    "arrayId": "array-javascript-intro",
    "posts": [
      {
        "id": "1",
        "title": "O que é JavaScript?",
        "docUrl": "https://www.javascript.com/learn/javascript/what-is-javascript",
        "content1": "JavaScript é uma linguagem de programação de alto nível, interpretada e orientada a objetos, que se consolidou como uma das tecnologias centrais da web moderna. Criada por Brendan Eich em 1995, enquanto trabalhava na Netscape, a linguagem foi inicialmente chamada de Mocha, depois LiveScript, antes de ser renomeada para JavaScript — uma decisão de marketing para associá-la ao popular Java, embora as duas linguagens sejam fundamentalmente diferentes. Originalmente projetada para adicionar interatividade simples a páginas web, como validação de formulários e animações básicas, o JavaScript evoluiu para uma linguagem poderosa e versátil, usada tanto no lado do cliente (client-side), executada diretamente nos navegadores, quanto no lado do servidor (server-side), graças ao Node.js, lançado em 2009. Essa dualidade permite que desenvolvedores construam aplicações completas, desde interfaces dinâmicas até APIs robustas, usando uma única linguagem.",
        "content2": "JavaScript é uma linguagem de tipagem dinâmica, o que significa que os tipos de variáveis são determinados em tempo de execução, sem a necessidade de declarações explícitas, oferecendo flexibilidade, mas exigindo cuidado para evitar erros. Ela suporta múltiplos paradigmas de programação: funcional (com funções de primeira classe e closures), orientada a objetos (baseada em protótipos, com suporte a classes desde o ES6) e imperativa. Um dos principais pontos fortes do JavaScript é sua capacidade de manipular o DOM (Document Object Model), permitindo a criação de interfaces interativas, como formulários dinâmicos, animações e atualizações em tempo real sem recarregar a página. A linguagem é suportada por todos os navegadores modernos e possui um ecossistema rico, com frameworks como React, Angular e Vue.js, que facilitam o desenvolvimento de aplicações web complexas. No entanto, a tipagem dinâmica e o comportamento assíncrono podem introduzir desafios, como erros difíceis de depurar, o que exige boas práticas, como o uso de ferramentas de linting (ex.: ESLint), testes automatizados e modularização de código.",
        "content3": "As aplicações do JavaScript são vastas e vão além do desenvolvimento web tradicional. No front-end, é usado para criar experiências interativas, como jogos em HTML5, validação de formulários e atualizações assíncronas via AJAX. No back-end, com Node.js, JavaScript é utilizado para construir servidores escaláveis, como em aplicações de chat em tempo real ou APIs RESTful. A linguagem também se expandiu para outras áreas, como desenvolvimento mobile (com frameworks como React Native), desktop (com Electron, usado em apps como Visual Studio Code) e até IoT (Internet das Coisas). Para desenvolvedores, é essencial dominar conceitos como assincronia (Promises, async/await), manipulação de eventos e gerenciamento de estado, além de seguir boas práticas, como modularização de código, uso de padrões de design e documentação clara, para garantir a manutenibilidade e escalabilidade das aplicações. Ferramentas como TypeScript podem ser usadas para adicionar tipagem estática, aumentando a confiabilidade em projetos de grande escala.",
        "docLink": "< Documentação oficial! />",
        "code": [
          {
            "description": "Exemplo 1: Uma função que solicita o nome do usuário e o armazena no localStorage, atualizando dinamicamente o título da página.",
            "javascript": "function setUserName() {\n  const myName = prompt('Por favor, digite seu nome:');\n  if (!myName) {\n    setUserName();\n  } else {\n    localStorage.setItem('name', myName);\n    document.querySelector('h1').textContent = `Bem-vindo, ${myName}!`;\n  }\n}\nsetUserName();"
          },
          {
            "description": "Exemplo 2: Alterando o texto de um parágrafo ao clicar em um botão, demonstrando manipulação dinâmica do DOM.",
            "javascript": "document.querySelector('#changeTextBtn').addEventListener('click', () => {\n  const paragraph = document.querySelector('#myParagraph');\n  paragraph.textContent = 'O texto foi alterado com JavaScript!';\n});"
          },
          {
            "description": "Exemplo 3: Exibindo a data e hora atuais no console a cada segundo, usando setInterval para atualizações dinâmicas.",
            "javascript": "function showCurrentTime() {\n  setInterval(() => {\n    const now = new Date();\n    console.log(`Hora atual: ${now.toLocaleTimeString()}`);\n  }, 1000);\n}\nshowCurrentTime();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "helloworld",
    "arrayId": "array-javascript-helloworld",
    "posts": [
      {
        "id": "2",
        "title": "Hello World em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/hello-world",
        "content1": "O 'Hello World' é um mito e uma lenda entre programadores, um rito de passagem que marca o primeiro passo no aprendizado de programação. Sua origem remonta aos anos 1970, quando Brian Kernighan o usou em um tutorial interno no Bell Labs para a linguagem B, predecessora do C, em 1972. Ele exibia 'hello, world' para demonstrar a sintaxe da linguagem de forma simples.",
        "content2": "O termo ganhou fama em 1978 com o livro *The C Programming Language*, de Kernighan e Dennis Ritchie, onde o 'Hello World' foi o primeiro exemplo, popularizando a tradição. A escolha da frase não tem uma razão clara, mas Kernighan mencionou uma vaga inspiração em um desenho animado com um pintinho dizendo 'Hello, World'.",
        "content3": "Hoje, o 'Hello World' é mais do que código: é um símbolo que conecta programadores ao longo de gerações, representando o momento em que o código 'ganha vida' e o programador se sente parte de uma comunidade global. Em JavaScript, ele pode ser exibido de várias formas, como você verá nos exemplos abaixo.",
        "docLink": "Consulte aqui a documentação oficial - Hello World JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Exibe 'Hello World' diretamente no console do navegador com console.log().",
            "javascript": "console.log('Hello World');"
          },
          {
            "description": "Exemplo 2: Usa uma função e um array para juntar as palavras 'Hello' e 'World' antes de exibir no console.",
            "javascript": "function helloWorldArray() {\n  const words = ['Hello', 'World'];\n  console.log(words.join(' '));\n}\nhelloWorldArray();"
          },
          {
            "description": "Exemplo 3: Exibe 'Hello World' em um elemento HTML ao clicar em um botão, interagindo com o DOM.",
            "javascript": "document.querySelector('#helloButton').addEventListener('click', () => {\n  const div = document.createElement('div');\n  div.textContent = 'Hello World';\n  div.style.fontSize = '20px';\n  div.style.color = 'blue';\n  document.body.appendChild(div);\n});"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "variables",
    "arrayId": "array-javascript-variables",
    "posts": [
      {
        "id": "3",
        "title": "Variáveis em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/variables",
        "content1": "Variáveis em JavaScript são usadas para armazenar dados que podem ser manipulados durante a execução do programa. JavaScript oferece três palavras-chave para declarar variáveis: `var`, `let` e `const`. A palavra-chave `var` é a forma mais antiga, mas tem problemas de escopo (escopo de função ou global), o que pode levar a erros. `let` e `const`, introduzidas no ES6 (2015), têm escopo de bloco, tornando o código mais previsível. `let` permite reatribuição de valores, enquanto `const` é usada para valores constantes que não podem ser reatribuídos (embora objetos e arrays declarados com `const` possam ter suas propriedades ou elementos modificados). A escolha entre essas palavras-chave depende do comportamento desejado para a variável, e boas práticas recomendam usar `const` por padrão, recorrendo a `let` apenas quando a reatribuição for necessária.",
        "docLink": "Consulte aqui a documentação oficial - Variáveis JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Declaração de variáveis usando var, let e const.",
            "javascript": "var x = 10; // Escopo de função ou global\nlet y = 20; // Escopo de bloco\nconst z = 30; // Escopo de bloco e valor constante\n\n// Reatribuição\nx = 15; // Permitido\n\ny = 25; // Permitido\n\n// z = 35; // Erro! Não é possível reatribuir a uma constante\n\n// Modificando propriedades de um objeto constante\nconst obj = { name: 'JavaScript' };\nobj.name = 'TypeScript'; // Permitido\n// obj = {}; // Erro! Não é possível reatribuir a uma constante"
          },
          {
            "description": "Exemplo 2: Escopo de variáveis com var, let e const.",
            "javascript": "// Escopo de var\nvar a = 1;\nif (true) {\n  var a = 2; // Sobrescreve a variável a do escopo externo\n  console.log(a); // 2\n}\nconsole.log(a); // 2\n\n// Escopo de let\nlet b = 1;\nif (true) {\n  let b = 2; // Cria uma nova variável b no escopo do bloco\n  console.log(b); // 2\n}\nconsole.log(b); // 1\n\n// Escopo de const\nconst c = 1;\nif (true) {\n  const c = 2; // Cria uma nova variável c no escopo do bloco\n  console.log(c); // 2\n}\nconsole.log(c); // 1"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "datatypes",
    "arrayId": "array-javascript-datatypes",
    "posts": [
      {
        "id": "4",
        "title": "Tipos de Dados em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/data-types",
        "content1": "JavaScript é uma linguagem de tipagem dinâmica, o que significa que os tipos de dados são determinados automaticamente durante a execução, sem a necessidade de declarações explícitas. Os principais tipos de dados em JavaScript são divididos em duas categorias: primitivos e não primitivos. Os tipos primitivos incluem `String` (textos), `Number` (números inteiros ou decimais), `Boolean` (verdadeiro ou falso), `null` (ausência de valor), `undefined` (valor não definido) e `Symbol` (identificador único, introduzido no ES6). Os tipos não primitivos incluem `Object` (estruturas de dados complexas, como objetos e funções) e `Array` (listas ordenadas). Além disso, JavaScript introduziu o tipo `BigInt` no ES2020 para lidar com números inteiros muito grandes. O operador `typeof` é usado para verificar o tipo de uma variável, embora tenha algumas peculiaridades, como retornar 'object' para `null`.",
        "docLink": "Consulte aqui a documentação oficial - Tipos de Dados JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Tipos primitivos em JavaScript.",
            "javascript": "// String\nconst texto = 'Olá, mundo!';\nconsole.log(typeof texto); // string\n\n// Number\nconst numero = 42;\nconst decimal = 3.14;\nconsole.log(typeof numero); // number\nconsole.log(typeof decimal); // number\n\n// Boolean\nconst verdadeiro = true;\nconst falso = false;\nconsole.log(typeof verdadeiro); // boolean\nconsole.log(typeof falso); // boolean\n\n// Null\nconst nulo = null;\nconsole.log(typeof nulo); // object (peculiaridade do JavaScript)\n\n// Undefined\nlet indefinido;\nconsole.log(typeof indefinido); // undefined\n\n// Symbol\nconst simbolo = Symbol('descrição');\nconsole.log(typeof simbolo); // symbol\n\n// BigInt\nconst grande = 9007199254740991n;\nconsole.log(typeof grande); // bigint"
          },
          {
            "description": "Exemplo 2: Tipos não primitivos em JavaScript.",
            "javascript": "// Object\nconst objeto = { nome: 'JavaScript', ano: 1995 };\nconsole.log(typeof objeto); // object\n\n// Array\nconst array = [1, 2, 3, 4, 5];\nconsole.log(typeof array); // object (arrays são objetos em JavaScript)\n\n// Function\nfunction funcao() {}\nconsole.log(typeof funcao); // function\n\n// Verificando se é um array\nconsole.log(Array.isArray(array)); // true\nconsole.log(Array.isArray(objeto)); // false"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "numbers",
    "arrayId": "array-javascript-numbers",
    "posts": [
      {
        "id": "5",
        "title": "Números e Operadores em JavaScript",
        "content1": "JavaScript trata todos os números como valores do tipo `Number`, que podem ser inteiros ou decimais (ponto flutuante). A linguagem suporta operações matemáticas básicas com operadores como adição (`+`), subtração (`-`), multiplicação (`*`), divisão (`/`), módulo (`%`) e exponenciação (`**`). Além disso, JavaScript oferece o objeto `Math` para operações mais avançadas, como arredondamento (`Math.round()`), geração de números aleatórios (`Math.random()`) e cálculo de raízes quadradas (`Math.sqrt()`). É importante estar atento a questões de precisão em números de ponto flutuante, como em `0.1 + 0.2`, que pode resultar em `0.30000000000000004` devido à forma como os números são representados internamente (padrão IEEE 754). Para números muito grandes, o tipo `BigInt` pode ser usado para evitar perda de precisão.",
        "docLink": "Consulte aqui a documentação oficial - Números e Operadores JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Operações matemáticas básicas em JavaScript.",
            "javascript": "// Adição\nconst soma = 5 + 3;\nconsole.log(soma); // 8\n\n// Subtração\nconst subtracao = 10 - 4;\nconsole.log(subtracao); // 6\n\n// Multiplicação\nconst multiplicacao = 6 * 7;\nconsole.log(multiplicacao); // 42\n\n// Divisão\nconst divisao = 15 / 3;\nconsole.log(divisao); // 5\n\n// Módulo (resto da divisão)\nconst modulo = 17 % 5;\nconsole.log(modulo); // 2\n\n// Exponenciação\nconst exponenciacao = 2 ** 3;\nconsole.log(exponenciacao); // 8"
          },
          {
            "description": "Exemplo 2: Uso do objeto Math para operações matemáticas avançadas.",
            "javascript": "// Arredondamento\nconsole.log(Math.round(4.6)); // 5\nconsole.log(Math.floor(4.6)); // 4\nconsole.log(Math.ceil(4.2)); // 5\n\n// Número aleatório entre 0 e 1\nconsole.log(Math.random()); // Valor aleatório entre 0 e 1\n\n// Número aleatório entre 1 e 10\nconst aleatorio = Math.floor(Math.random() * 10) + 1;\nconsole.log(aleatorio); // Valor aleatório entre 1 e 10\n\n// Raiz quadrada\nconsole.log(Math.sqrt(16)); // 4\n\n// Valor absoluto\nconsole.log(Math.abs(-7)); // 7\n\n// Máximo e mínimo\nconsole.log(Math.max(10, 20, 30)); // 30\nconsole.log(Math.min(10, 20, 30)); // 10"
          },
          {
            "description": "Exemplo 3: Problemas de precisão com números de ponto flutuante e uso de BigInt.",
            "javascript": "// Problema de precisão com números de ponto flutuante\nconsole.log(0.1 + 0.2); // 0.30000000000000004\nconsole.log(0.1 + 0.2 === 0.3); // false\n\n// Solução: arredondar para um número específico de casas decimais\nconsole.log((0.1 + 0.2).toFixed(2)); // '0.30'\nconsole.log(Number((0.1 + 0.2).toFixed(2))); // 0.3\n\n// Uso de BigInt para números inteiros muito grandes\nconst grande = 9007199254740991n;\nconsole.log(grande + 1n); // 9007199254740992n\n\n// Não é possível misturar Number e BigInt\n// console.log(grande + 1); // Erro: Cannot mix BigInt and other types\nconsole.log(grande + BigInt(1)); // 9007199254740992n"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "boolean",
    "arrayId": "array-javascript-boolean",
    "posts": [
      {
        "id": "6",
        "title": "Booleanos e Estruturas Condicionais",
        "content1": "O tipo `Boolean` em JavaScript representa valores lógicos: `true` (verdadeiro) ou `false` (falso). Booleanos são amplamente usados em estruturas condicionais, como `if`, `else if` e `else`, para controlar o fluxo de execução do programa com base em condições. JavaScript também converte automaticamente outros tipos de dados em booleanos em contextos lógicos (um processo chamado coerção), onde valores como `0`, `''` (string vazia), `null`, `undefined` e `NaN` são considerados `falsy` (equivalem a `false`), enquanto outros valores, como strings não vazias, números diferentes de zero e objetos, são considerados `truthy` (equivalem a `true`). Além disso, operadores lógicos como `&&` (AND), `||` (OR) e `!` (NOT) são usados para combinar ou inverter condições. Estruturas condicionais são fundamentais para tomar decisões no código, como validar entradas de usuário ou determinar fluxos de execução.",
        "docLink": "Consulte aqui a documentação oficial - Booleanos e Estruturas Condicionais JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Uso de estruturas condicionais if, else if e else.",
            "javascript": "function verificarIdade(idade) {\n  if (idade >= 18) {\n    return 'Maior de idade';\n  } else if (idade >= 12) {\n    return 'Adolescente';\n  } else {\n    return 'Menor de idade';\n  }\n}\n\nconsole.log(verificarIdade(20)); // 'Maior de idade'\nconsole.log(verificarIdade(15)); // 'Adolescente'\nconsole.log(verificarIdade(8)); // 'Menor de idade'"
          },
          {
            "description": "Exemplo 2: Operadores lógicos && (AND), || (OR) e ! (NOT).",
            "javascript": "// Operador AND (&&)\nconsole.log(true && true); // true\nconsole.log(true && false); // false\nconsole.log(false && true); // false\nconsole.log(false && false); // false\n\n// Operador OR (||)\nconsole.log(true || true); // true\nconsole.log(true || false); // true\nconsole.log(false || true); // true\nconsole.log(false || false); // false\n\n// Operador NOT (!)\nconsole.log(!true); // false\nconsole.log(!false); // true\n\n// Combinação de operadores\nconsole.log(!(true && false)); // true\nconsole.log(!true || !false); // true"
          },
          {
            "description": "Exemplo 3: Valores truthy e falsy em JavaScript.",
            "javascript": "// Valores falsy\nconsole.log(Boolean(false)); // false\nconsole.log(Boolean(0)); // false\nconsole.log(Boolean('')); // false\nconsole.log(Boolean(null)); // false\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(NaN)); // false\n\n// Valores truthy\nconsole.log(Boolean(true)); // true\nconsole.log(Boolean(42)); // true\nconsole.log(Boolean('Hello')); // true\nconsole.log(Boolean({})); // true\nconsole.log(Boolean([])); // true\n\n// Uso em condicionais\nfunction verificarValor(valor) {\n  if (valor) {\n    console.log('Valor é truthy');\n  } else {\n    console.log('Valor é falsy');\n  }\n}\n\nverificarValor(0); // 'Valor é falsy'\nverificarValor(''); // 'Valor é falsy'\nverificarValor(42); // 'Valor é truthy'\nverificarValor('Hello'); // 'Valor é truthy'"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "functions",
    "arrayId": "array-javascript-functions",
    "posts": [
      {
        "id": "7",
        "title": "Funções em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/functions",
        "content1": "Funções são blocos de código reutilizáveis que executam uma tarefa específica e podem ser chamadas em diferentes partes do programa. Em JavaScript, funções podem ser declaradas usando a palavra-chave `function`, expressões de função ou a sintaxe de arrow functions (introduzida no ES6). Elas podem receber parâmetros, que permitem passar dados para a função, e retornar valores usando a palavra-chave `return`. Funções também podem ser anônimas (sem nome) ou imediatamente invocadas (IIFE - Immediately Invoked Function Expression). Além disso, JavaScript suporta funções de ordem superior, que podem receber outras funções como argumentos ou retorná-las, o que é essencial para programação funcional. Funções são fundamentais para organizar o código, evitar repetição e implementar lógica modular.",
        "docLink": "Consulte aqui a documentação oficial - Funções JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Declaração de uma função que calcula o quadrado de um número e retorna o resultado.",
            "javascript": "function square(number) {\n  return number * number;\n}\nconsole.log(square(5)); // 25"
          },
          {
            "description": "Exemplo 2: Uso de uma arrow function para somar dois números, mostrando uma sintaxe mais concisa.",
            "javascript": "const add = (a, b) => a + b;\nconsole.log(add(3, 4)); // 7"
          },
          {
            "description": "Exemplo 3: Função de ordem superior que aplica uma operação a dois números, recebendo a operação como argumento.",
            "javascript": "function applyOperation(a, b, operation) {\n  return operation(a, b);\n}\nconst multiply = (x, y) => x * y;\nconsole.log(applyOperation(5, 3, multiply)); // 15"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "objects",
    "arrayId": "array-javascript-objects",
    "posts": [
      {
        "id": "15",
        "title": "Objetos em JavaScript",
        "content1": "Objetos são estruturas fundamentais em JavaScript que permitem armazenar coleções de dados relacionados. Eles são compostos por pares de chave-valor e podem conter propriedades e métodos. JavaScript oferece várias formas de criar e manipular objetos, incluindo notação literal, construtores e Object.create(). Além disso, recursos como getters, setters e Object.defineProperty() permitem um controle mais refinado sobre as propriedades dos objetos.",
        "docLink": "Consulte aqui a documentação oficial - Objetos JavaScript",
        "code": [
          {
            "description": "Exemplo de criação e manipulação de objetos",
            "javascript": "// Criando um objeto usando notação literal\nconst pessoa = {\n  nome: 'João',\n  idade: 30,\n  saudacao() {\n    return `Olá, meu nome é ${this.nome}`;\n  }\n};\n\n// Usando getter e setter\nconst conta = {\n  _saldo: 0,\n  get saldo() {\n    return this._saldo;\n  },\n  set saldo(valor) {\n    if (valor >= 0) {\n      this._saldo = valor;\n    }\n  }\n};"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "arrays",
    "arrayId": "array-javascript-arrays",
    "posts": [
      {
        "id": "9",
        "title": "Arrays em JavaScript",
        "content1": "Arrays são estruturas de dados que permitem armazenar múltiplos valores em uma única variável. Em JavaScript, arrays são objetos especiais que podem conter diferentes tipos de dados, incluindo números, strings, objetos e até mesmo outros arrays. Os elementos em um array são indexados numericamente, começando do índice 0. JavaScript fornece diversos métodos úteis para manipular arrays, como push(), pop(), shift(), unshift(), splice(), slice(), map(), filter(), reduce(), entre outros. Arrays são fundamentais para o processamento de dados e são amplamente utilizados em programação JavaScript.",
        "docLink": "Consulte aqui a documentação oficial - Arrays JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Criando e manipulando arrays",
            "javascript": "// Criando arrays\nconst frutas = ['maçã', 'banana', 'laranja'];\nconst numeros = [1, 2, 3, 4, 5];\nconst misto = [1, 'texto', true, null, { chave: 'valor' }];\n\n// Acessando elementos\nconsole.log(frutas[0]); // 'maçã'\nconsole.log(numeros[2]); // 3\n\n// Modificando elementos\nfrutas[1] = 'pera';\nconsole.log(frutas); // ['maçã', 'pera', 'laranja']\n\n// Adicionando e removendo elementos\nfrutas.push('uva'); // Adiciona ao final\nfrutas.pop(); // Remove do final\nfrutas.unshift('morango'); // Adiciona ao início\nfrutas.shift(); // Remove do início"
          },
          {
            "description": "Exemplo 2: Métodos de array",
            "javascript": "const numeros = [1, 2, 3, 4, 5];\n\n// map - cria novo array com resultados\nconst dobrados = numeros.map(num => num * 2);\nconsole.log(dobrados); // [2, 4, 6, 8, 10]\n\n// filter - cria novo array com elementos que passam no teste\nconst pares = numeros.filter(num => num % 2 === 0);\nconsole.log(pares); // [2, 4]\n\n// reduce - reduz array a um único valor\nconst soma = numeros.reduce((acc, curr) => acc + curr, 0);\nconsole.log(soma); // 15\n\n// forEach - executa função para cada elemento\nnumeros.forEach(num => console.log(num));"
          },
          {
            "description": "Exemplo 3: Métodos de busca e ordenação",
            "javascript": "const frutas = ['maçã', 'banana', 'laranja', 'uva'];\n\n// indexOf - encontra índice do elemento\nconsole.log(frutas.indexOf('banana')); // 1\n\n// includes - verifica se elemento existe\nconsole.log(frutas.includes('uva')); // true\n\n// sort - ordena o array\nfrutas.sort();\nconsole.log(frutas); // ['banana', 'laranja', 'maçã', 'uva']\n\n// reverse - inverte a ordem\nfrutas.reverse();\nconsole.log(frutas); // ['uva', 'maçã', 'laranja', 'banana']"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "scope",
    "arrayId": "array-javascript-scope",
    "posts": [
      {
        "id": "16",
        "title": "Escopo em JavaScript",
        "content1": "O escopo em JavaScript determina a visibilidade e acessibilidade de variáveis, funções e objetos em diferentes partes do código. JavaScript tem escopo de bloco (let e const), escopo de função (var) e escopo global. O conceito de closure permite que funções mantenham acesso ao seu escopo léxico mesmo quando executadas em um escopo diferente. Entender escopo é fundamental para evitar vazamento de variáveis e criar código mais organizado.",
        "docLink": "Consulte aqui a documentação oficial - Escopo JavaScript",
        "code": [
          {
            "description": "Exemplo de diferentes tipos de escopo e closure",
            "javascript": "// Escopo de bloco vs função\nfunction exemploEscopo() {\n  var funcao = 'visível em toda função';\n  let bloco = 'visível apenas no bloco';\n  \n  if (true) {\n    let bloco = 'novo valor';\n    console.log(bloco); // 'novo valor'\n  }\n  \n  console.log(bloco); // 'visível apenas no bloco'\n}\n\n// Exemplo de closure\nfunction criarContador() {\n  let count = 0;\n  return {\n    incrementar: () => ++count,\n    obterValor: () => count\n  };\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "dom",
    "arrayId": "array-javascript-dom",
    "posts": [
      {
        "id": "11",
        "title": "DOM em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/dom",
        "content1": "O DOM (Document Object Model) é uma interface de programação que representa documentos HTML e XML como uma estrutura de árvore, onde cada elemento, atributo e texto é um nó. O DOM permite que JavaScript interaja dinamicamente com a página web, manipulando elementos, alterando estilos, adicionando ou removendo conteúdo, e respondendo a eventos do usuário. Cada elemento HTML é representado como um nó no DOM, e você pode navegar entre esses nós usando propriedades como `parentNode`, `childNodes`, `firstChild`, `lastChild`, `nextSibling` e `previousSibling`. Além disso, o DOM fornece métodos para selecionar elementos, como `getElementById()`, `getElementsByClassName()`, `getElementsByTagName()`, `querySelector()` e `querySelectorAll()`, que permitem encontrar e manipular elementos específicos na página.",
        "docLink": "Consulte aqui a documentação oficial - DOM JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Acessando e exibindo o título da página via DOM.",
            "javascript": "function accessDOM() {\n  const title = document.querySelector('title').textContent;\n  console.log('Título da página:', title);\n}\naccessDOM();"
          },
          {
            "description": "Exemplo 2: Alterando o texto de um parágrafo e sua cor de fundo via DOM.",
            "javascript": "function modifyDOM() {\n  const paragraph = document.querySelector('#myParagraph');\n  paragraph.textContent = 'Texto alterado via DOM!';\n  paragraph.style.backgroundColor = 'lightblue';\n}\nmodifyDOM();"
          },
          {
            "description": "Exemplo 3: Criando e adicionando um novo elemento ao DOM dinamicamente.",
            "javascript": "function addElementToDOM() {\n  const newDiv = document.createElement('div');\n  newDiv.textContent = 'Novo elemento criado!';\n  newDiv.style.color = 'green';\n  document.body.appendChild(newDiv);\n}\naddElementToDOM();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "selectors",
    "arrayId": "array-javascript-selectors",
    "posts": [
      {
        "id": "12",
        "title": "Selecionando Elementos no DOM",
        "content1": "JavaScript oferece diversos métodos para selecionar elementos no DOM, permitindo interagir com a página web de forma dinâmica. O método `getElementById()` seleciona um elemento pelo seu ID, retornando um único elemento ou `null` se não encontrar. `getElementsByClassName()` retorna uma coleção de elementos que possuem a classe especificada, enquanto `getElementsByTagName()` retorna uma coleção de elementos com a tag HTML especificada. Os métodos mais modernos e flexíveis são `querySelector()` e `querySelectorAll()`, que aceitam seletores CSS, permitindo selecionar elementos de forma mais precisa e complexa. `querySelector()` retorna o primeiro elemento que corresponde ao seletor, enquanto `querySelectorAll()` retorna uma coleção de todos os elementos que correspondem. É importante entender que `getElementsByClassName()` e `getElementsByTagName()` retornam coleções HTMLCollection, que são atualizadas automaticamente quando o DOM muda, enquanto `querySelectorAll()` retorna uma NodeList estática.",
        "docLink": "Consulte aqui a documentação oficial - Seletores JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Seleção de elementos usando `getElementById()` e `querySelector()`.",
            "javascript": "function selectElements() {\n  const byId = document.getElementById('myId');\n  const byQuery = document.querySelector('.myClass');\n  console.log('Por ID:', byId);\n  console.log('Por querySelector:', byQuery);\n}\nselectElements();"
          },
          {
            "description": "Exemplo 2: Seleção de múltiplos elementos com `querySelectorAll()` e iteração sobre eles.",
            "javascript": "function selectMultipleElements() {\n  const items = document.querySelectorAll('li');\n  items.forEach(item => {\n    item.style.color = 'blue';\n  });\n}\nselectMultipleElements();"
          },
          {
            "description": "Exemplo 3: Uso de `getElementsByClassName()` para alterar o texto de elementos com uma classe específica.",
            "javascript": "function selectByClass() {\n  const elements = document.getElementsByClassName('highlight');\n  for (let element of elements) {\n    element.textContent = 'Texto alterado!';\n  }\n}\nselectByClass();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "foreach",
    "arrayId": "array-javascript-foreach",
    "posts": [
      {
        "id": "13",
        "title": "Método forEach e Arrow Functions",
        "content1": "O método `forEach()` é uma forma prática de iterar sobre os elementos de um array em JavaScript, executando uma função de callback para cada elemento. Ele é mais declarativo do que loops tradicionais como `for` ou `while`, tornando o código mais legível e funcional. A função de callback pode receber até três argumentos: o elemento atual, o índice e o array original. Arrow functions, introduzidas no ES6, oferecem uma sintaxe mais concisa para escrever funções, especialmente em callbacks, usando a sintaxe `(param) => expressão`. Elas também têm a vantagem de não criar um novo `this`, herdando o contexto do escopo pai, o que é útil em métodos como `forEach()` quando usados dentro de objetos. Combinar `forEach()` com arrow functions é uma prática comum em JavaScript moderno para manipular arrays de forma eficiente.",
        "code": [
          {
            "description": "Exemplo 1: Uso de `forEach()` com uma arrow function para dobrar os valores de um array.",
            "javascript": "function useForEach() {\n  const numbers = [1, 2, 3];\n  numbers.forEach(num => console.log(num * 2));\n}\nuseForEach(); // 2, 4, 6"
          },
          {
            "description": "Exemplo 2: Uso de `forEach()` com índice para exibir a posição de cada elemento.",
            "javascript": "function forEachWithIndex() {\n  const fruits = ['Maçã', 'Banana', 'Laranja'];\n  fruits.forEach((fruit, index) => {\n    console.log(`Fruta ${index + 1}: ${fruit}`);\n  });\n}\nforEachWithIndex();"
          },
          {
            "description": "Exemplo 3: Uso de `forEach()` dentro de um objeto, com arrow function, para evitar problemas com `this`.",
            "javascript": "function forEachInObject() {\n  const obj = {\n    items: ['Item 1', 'Item 2', 'Item 3'],\n    showItems() {\n      this.items.forEach(item => console.log(`${item} pertence a obj`));\n    }\n  };\n  obj.showItems();\n}\nforEachInObject();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "classes",
    "arrayId": "array-javascript-classes",
    "posts": [
      {
        "id": "14",
        "title": "Manipulação de Classes e Atributos no DOM",
        "content1": "JavaScript permite manipular classes CSS e atributos de elementos HTML no DOM para alterar dinamicamente a aparência e o comportamento da página. A propriedade `classList` oferece métodos como `add()`, `remove()`, `toggle()` e `contains()` para gerenciar classes CSS de um elemento, sendo uma alternativa mais segura e prática do que manipular diretamente a propriedade `className`. Para atributos HTML, métodos como `setAttribute()`, `getAttribute()` e `removeAttribute()` permitem adicionar, ler ou remover atributos, como `id`, `data-*` ou `href`. Atributos personalizados (data attributes) são amplamente usados para armazenar informações adicionais em elementos, acessíveis via `dataset`. Essas técnicas são essenciais para criar interfaces dinâmicas, como destacar elementos, alternar temas ou armazenar metadados.",
        "code": [
          {
            "description": "Exemplo 1: Adicionando e removendo classes CSS com `classList`.",
            "javascript": "function manipulateClasses() {\n  const element = document.querySelector('#myElement');\n  element.classList.add('highlight');\n  element.classList.remove('hidden');\n  console.log(element.classList);\n}\nmanipulateClasses();"
          },
          {
            "description": "Exemplo 2: Alternando uma classe com `toggle()` e verificando sua presença com `contains()`.",
            "javascript": "function toggleClass() {\n  const button = document.querySelector('#toggleBtn');\n  button.classList.toggle('active');\n  if (button.classList.contains('active')) {\n    console.log('Botão está ativo');\n  } else {\n    console.log('Botão não está ativo');\n  }\n}\ntoggleClass();"
          },
          {
            "description": "Exemplo 3: Manipulando atributos personalizados (data attributes) com `setAttribute()` e `dataset`.",
            "javascript": "function manipulateAttributes() {\n  const element = document.querySelector('#myElement');\n  element.setAttribute('data-info', 'teste');\n  console.log(element.getAttribute('data-info')); // 'teste'\n  element.dataset.status = 'ativo';\n  console.log(element.dataset.status); // 'ativo'\n}\nmanipulateAttributes();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "events",
    "arrayId": "array-javascript-events",
    "posts": [
      {
        "id": "13",
        "title": "Eventos em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/events",
        "content1": "Eventos em JavaScript são ações ou ocorrências que acontecem na página web, como cliques, movimentos do mouse, pressionamento de teclas ou submissão de formulários. O método `addEventListener()` é usado para anexar manipuladores de eventos a elementos, permitindo que o código responda a essas ações. Cada evento tem um tipo (como 'click', 'mouseover', 'keydown') e pode carregar informações adicionais no objeto de evento passado para o manipulador. Eventos podem ser propagados (bubbling) ou capturados, e você pode controlar esse comportamento usando `stopPropagation()` ou `stopImmediatePropagation()`. Além disso, eventos podem ser removidos usando `removeEventListener()`, e você pode criar eventos personalizados usando o construtor `CustomEvent`. O gerenciamento adequado de eventos é crucial para criar interfaces interativas e responsivas.",
        "docLink": "Consulte aqui a documentação oficial - Eventos JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Adicionando um evento de clique a um botão para exibir um alerta.",
            "javascript": "function addEvent() {\n  const button = document.querySelector('#myButton');\n  button.addEventListener('click', () => {\n    alert('Botão clicado!');\n  });\n}\naddEvent();"
          },
          {
            "description": "Exemplo 2: Capturando a tecla pressionada em um campo de entrada com o evento `keydown`.",
            "javascript": "function keydownEvent() {\n  const input = document.querySelector('#myInput');\n  input.addEventListener('keydown', (event) => {\n    console.log(`Tecla pressionada: ${event.key}`);\n  });\n}\nkeydownEvent();"
          },
          {
            "description": "Exemplo 3: Prevenindo o envio de um formulário e exibindo os dados inseridos.",
            "javascript": "function formEvent() {\n  const form = document.querySelector('#myForm');\n  form.addEventListener('submit', (event) => {\n    event.preventDefault();\n    const inputValue = document.querySelector('#formInput').value;\n    console.log('Valor do formulário:', inputValue);\n  });\n}\nformEvent();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "outerhtml",
    "arrayId": "array-javascript-outerhtml",
    "posts": [
      {
        "id": "16",
        "title": "Propriedade outerHTML",
        "content1": "A propriedade `outerHTML` em JavaScript permite ler ou definir o código HTML de um elemento, incluindo o próprio elemento e todo o seu conteúdo interno. Quando você lê `outerHTML`, obtém uma string com o HTML completo do elemento (por exemplo, `<div>Conteúdo</div>`). Quando você define um novo valor para `outerHTML`, o elemento original é completamente substituído pelo novo HTML. Isso é diferente de `innerHTML`, que afeta apenas o conteúdo interno do elemento, sem incluir a tag do próprio elemento. O uso de `outerHTML` é útil para substituições completas de elementos no DOM, mas deve ser usado com cuidado, pois pode remover ouvintes de eventos associados ao elemento original, já que ele é substituído por um novo nó.",
        "code": [
          {
            "description": "Exemplo 1: Substituindo um elemento por um novo parágrafo usando `outerHTML`.",
            "javascript": "function changeOuterHTML() {\n  const element = document.querySelector('#myDiv');\n  element.outerHTML = '<p>Novo parágrafo</p>';\n}\nchangeOuterHTML();"
          },
          {
            "description": "Exemplo 2: Lendo o `outerHTML` de um elemento e exibindo no console.",
            "javascript": "function readOuterHTML() {\n  const element = document.querySelector('#myDiv');\n  console.log('HTML completo:', element.outerHTML);\n}\nreadOuterHTML();"
          },
          {
            "description": "Exemplo 3: Substituindo um elemento e adicionando um evento ao novo elemento.",
            "javascript": "function replaceWithEvent() {\n  const element = document.querySelector('#myDiv');\n  element.outerHTML = '<button id=\"newBtn\">Novo botão</button>';\n  document.querySelector('#newBtn').addEventListener('click', () => {\n    alert('Novo botão clicado!');\n  });\n}\nreplaceWithEvent();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "innerhtml",
    "arrayId": "array-javascript-innerhtml",
    "posts": [
      {
        "id": "17",
        "title": "Propriedade innerHTML",
        "content1": "A propriedade `innerHTML` permite ler ou definir o conteúdo HTML dentro de um elemento, sem incluir a tag do próprio elemento. Por exemplo, para um elemento `<div>Conteúdo</div>`, `innerHTML` retorna apenas `Conteúdo` (ou o HTML interno, se houver). Quando você define um novo valor para `innerHTML`, o conteúdo existente é substituído pelo novo HTML, que é analisado e renderizado pelo navegador. Essa propriedade é amplamente usada para atualizar dinamicamente o conteúdo de uma página, como exibir dados de uma API ou criar elementos a partir de strings HTML. No entanto, deve-se ter cuidado ao usar `innerHTML` com dados fornecidos pelo usuário, pois isso pode levar a vulnerabilidades de segurança, como ataques de Cross-Site Scripting (XSS). Para maior segurança, prefira métodos como `textContent` ou sanitize os dados antes de usá-los.",
        "code": [
          {
            "description": "Exemplo 1: Alterando o conteúdo HTML de um elemento com `innerHTML`.",
            "javascript": "function changeInnerHTML() {\n  const container = document.querySelector('#container');\n  container.innerHTML = '<span>Conteúdo novo</span>';\n}\nchangeInnerHTML();"
          },
          {
            "description": "Exemplo 2: Adicionando uma lista HTML dinamicamente com `innerHTML`.",
            "javascript": "function createList() {\n  const list = document.querySelector('#myList');\n  const items = ['Item 1', 'Item 2', 'Item 3'];\n  let html = '<ul>';\n  items.forEach(item => {\n    html += `<li>${item}</li>`;\n  });\n  html += '</ul>';\n  list.innerHTML = html;\n}\ncreateList();"
          },
          {
            "description": "Exemplo 3: Lendo o `innerHTML` de um elemento e exibindo no console.",
            "javascript": "function readInnerHTML() {\n  const container = document.querySelector('#container');\n  console.log('Conteúdo HTML interno:', container.innerHTML);\n}\nreadInnerHTML();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "innertext",
    "arrayId": "array-javascript-innertext",
    "posts": [
      {
        "id": "18",
        "title": "Propriedade innerText",
        "content1": "A propriedade `innerText` representa o texto visível dentro de um elemento, excluindo tags HTML e conteúdo oculto (como elementos com `display: none`). Diferentemente de `innerHTML`, que lida com o código HTML bruto, `innerText` retorna ou define apenas o texto renderizado, ignorando a formatação HTML. Por exemplo, para um elemento `<div><span>Texto</span></div>`, `innerText` retorna apenas `Texto`. Essa propriedade é útil para manipular texto de forma segura, sem o risco de injetar HTML malicioso, o que a torna uma alternativa mais segura do que `innerHTML` em cenários onde apenas texto é necessário. No entanto, `innerText` pode ser mais lenta que `textContent`, pois considera estilos CSS e a renderização do texto, enquanto `textContent` retorna todo o texto bruto, incluindo conteúdo oculto.",
        "code": [
          {
            "description": "Exemplo 1: Alterando o texto visível de um elemento com `innerText`.",
            "javascript": "function changeInnerText() {\n  const element = document.querySelector('#text');\n  element.innerText = 'Novo texto visível';\n}\nchangeInnerText();"
          },
          {
            "description": "Exemplo 2: Comparando `innerText` e `textContent` em um elemento com conteúdo oculto.",
            "javascript": "function compareText() {\n  const element = document.querySelector('#myDiv');\n  element.innerHTML = 'Texto visível <span style=\"display: none;\">Texto oculto</span>';\n  console.log('innerText:', element.innerText); // 'Texto visível'\n  console.log('textContent:', element.textContent); // 'Texto visível Texto oculto'\n}\ncompareText();"
          },
          {
            "description": "Exemplo 3: Atualizando o texto de vários elementos com uma classe específica usando `innerText`.",
            "javascript": "function updateMultipleTexts() {\n  const elements = document.querySelectorAll('.textItem');\n  elements.forEach((el, index) => {\n    el.innerText = `Item ${index + 1}`;\n  });\n}\nupdateMultipleTexts();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "traversing",
    "arrayId": "array-javascript-traversing",
    "posts": [
      {
        "id": "19",
        "title": "Navegação no DOM (Traversing)",
        "content1": "Traversing no DOM refere-se à navegação entre elementos HTML usando propriedades e métodos do DOM, como `parentNode`, `children`, `nextSibling`, `previousSibling`, `firstChild` e `lastChild`. Essas propriedades permitem acessar elementos relacionados hierarquicamente, como pais, filhos ou irmãos, sem a necessidade de seletores adicionais. Por exemplo, `parentNode` retorna o elemento pai de um nó, enquanto `children` retorna uma coleção de elementos filhos. `nextSibling` e `previousSibling` navegam entre irmãos, mas podem incluir nós de texto ou comentários, então é comum usar `nextElementSibling` e `previousElementSibling` para focar apenas em elementos HTML. Traversing é útil para manipular estruturas complexas, como listas ou árvores, e para implementar funcionalidades como navegação em abas ou acordeões.",
        "code": [
          {
            "description": "Exemplo 1: Navegando para o pai e o próximo irmão de um elemento.",
            "javascript": "function traverseDOM() {\n  const element = document.querySelector('#child');\n  const parent = element.parentNode;\n  const next = element.nextElementSibling;\n  console.log('Pai:', parent);\n  console.log('Próximo irmão:', next);\n}\ntraverseDOM();"
          },
          {
            "description": "Exemplo 2: Acessando todos os filhos de um elemento e alterando seus estilos.",
            "javascript": "function styleChildren() {\n  const parent = document.querySelector('#parent');\n  const children = parent.children;\n  for (let child of children) {\n    child.style.border = '1px solid black';\n  }\n}\nstyleChildren();"
          },
          {
            "description": "Exemplo 3: Navegando até o primeiro e último filho de um elemento.",
            "javascript": "function firstAndLastChild() {\n  const list = document.querySelector('#myList');\n  const first = list.firstElementChild;\n  const last = list.lastElementChild;\n  first.style.color = 'red';\n  last.style.color = 'blue';\n}\nfirstAndLastChild();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "tabs",
    "arrayId": "array-javascript-tabs",
    "posts": [
      {
        "id": "20",
        "title": "Navegação em Abas (Tabs)",
        "content1": "A navegação em abas (tabs) é uma técnica comum em interfaces web para organizar conteúdo em seções, exibindo apenas uma seção por vez. Cada aba é associada a um painel de conteúdo, e ao clicar em uma aba, o painel correspondente é exibido, enquanto os outros são ocultados. Isso é implementado com JavaScript manipulando classes CSS (como `active`) para controlar a visibilidade dos painéis e o estilo das abas. Geralmente, usa-se `querySelectorAll()` para selecionar todas as abas e painéis, e `addEventListener()` para adicionar eventos de clique às abas. A lógica envolve remover a classe `active` de todos os painéis e abas antes de aplicá-la ao par aba/painel selecionado. Essa técnica melhora a experiência do usuário ao organizar informações de forma clara e acessível, sendo comum em sites com muito conteúdo, como documentações ou dashboards.",
        "code": [
          {
            "description": "Exemplo 1: Implementação básica de navegação em abas, alternando a visibilidade dos painéis.",
            "javascript": "function setupTabs() {\n  const tabs = document.querySelectorAll('.tab');\n  const contents = document.querySelectorAll('.content');\n  tabs.forEach((tab, index) => {\n    tab.addEventListener('click', () => {\n      contents.forEach(c => c.classList.remove('active'));\n      tabs.forEach(t => t.classList.remove('active'));\n      contents[index].classList.add('active');\n      tab.classList.add('active');\n    });\n  });\n}\nsetupTabs();"
          },
          {
            "description": "Exemplo 2: Adicionando um efeito de transição ao mudar de aba.",
            "javascript": "function setupTabsWithTransition() {\n  const tabs = document.querySelectorAll('.tab');\n  const contents = document.querySelectorAll('.content');\n  tabs.forEach((tab, index) => {\n    tab.addEventListener('click', () => {\n      contents.forEach(c => {\n        c.classList.remove('active');\n        c.style.opacity = '0';\n      });\n      tabs.forEach(t => t.classList.remove('active'));\n      contents[index].classList.add('active');\n      contents[index].style.opacity = '1';\n      tab.classList.add('active');\n    });\n  });\n}\nsetupTabsWithTransition();"
          },
          {
            "description": "Exemplo 3: Definindo a primeira aba como ativa por padrão ao carregar a página.",
            "javascript": "function setupTabsWithDefault() {\n  const tabs = document.querySelectorAll('.tab');\n  const contents = document.querySelectorAll('.content');\n  tabs[0].classList.add('active');\n  contents[0].classList.add('active');\n  tabs.forEach((tab, index) => {\n    tab.addEventListener('click', () => {\n      contents.forEach(c => c.classList.remove('active'));\n      tabs.forEach(t => t.classList.remove('active'));\n      contents[index].classList.add('active');\n      tab.classList.add('active');\n    });\n  });\n}\nsetupTabsWithDefault();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "accordion",
    "arrayId": "array-javascript-accordion",
    "posts": [
      {
        "id": "21",
        "title": "Componente Accordion",
        "content1": "Um componente accordion (acordeão) é uma interface que permite expandir e recolher seções de conteúdo, exibindo apenas uma seção por vez ou várias, dependendo da implementação. É útil para organizar informações em espaços limitados, como FAQs ou listas de tópicos, melhorando a experiência do usuário ao evitar sobrecarga visual. Em JavaScript, um accordion é implementado associando eventos de clique aos cabeçalhos das seções, que alternam a visibilidade do conteúdo associado (geralmente usando `display: block` ou `display: none`). Pode-se usar `nextElementSibling` para acessar o conteúdo imediatamente após o cabeçalho, e classes CSS podem ser usadas para adicionar transições suaves. Um accordion bem projetado deve ser acessível, com suporte a navegação por teclado e atributos ARIA para leitores de tela.",
        "code": [
          {
            "description": "Exemplo 1: Implementação básica de um accordion, alternando a visibilidade do conteúdo.",
            "javascript": "function setupAccordion() {\n  const headers = document.querySelectorAll('.accordion-header');\n  headers.forEach(header => {\n    header.addEventListener('click', () => {\n      const content = header.nextElementSibling;\n      content.style.display = content.style.display === 'block' ? 'none' : 'block';\n    });\n  });\n}\nsetupAccordion();"
          },
          {
            "description": "Exemplo 2: Accordion que fecha outras seções ao abrir uma nova, garantindo que apenas uma esteja visível.",
            "javascript": "function setupExclusiveAccordion() {\n  const headers = document.querySelectorAll('.accordion-header');\n  headers.forEach(header => {\n    header.addEventListener('click', () => {\n      const content = header.nextElementSibling;\n      headers.forEach(h => {\n        const c = h.nextElementSibling;\n        if (c !== content) c.style.display = 'none';\n      });\n      content.style.display = content.style.display === 'block' ? 'none' : 'block';\n    });\n  });\n}\nsetupExclusiveAccordion();"
          },
          {
            "description": "Exemplo 3: Adicionando uma transição suave à abertura e fechamento do accordion.",
            "javascript": "function setupAccordionWithTransition() {\n  const headers = document.querySelectorAll('.accordion-header');\n  headers.forEach(header => {\n    header.addEventListener('click', () => {\n      const content = header.nextElementSibling;\n      if (content.style.maxHeight) {\n        content.style.maxHeight = null;\n      } else {\n        content.style.maxHeight = content.scrollHeight + 'px';\n      }\n    });\n  });\n}\nsetupAccordionWithTransition();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "smoothscroll",
    "arrayId": "array-javascript-smoothscroll",
    "posts": [
      {
        "id": "22",
        "title": "Navegação Suave com Smooth Scroll",
        "content1": "A navegação suave (smooth scroll) melhora a experiência do usuário ao rolar a página de forma fluida até um elemento alvo, em vez de um salto abrupto. Em JavaScript, isso pode ser implementado usando o método `scrollIntoView()` com a opção `behavior: 'smooth'`, que é suportada nativamente pelos navegadores modernos. Para links internos (âncoras com `href='#id'`), seleciona-se todos os links correspondentes com `querySelectorAll()` e adiciona-se um evento de clique que previne o comportamento padrão (`preventDefault()`) e rola até o elemento alvo. Smooth scroll é especialmente útil em páginas longas, como landing pages ou documentações, onde o usuário precisa navegar entre seções. Além disso, pode-se combinar com animações CSS ou bibliotecas como `scroll-behavior` para maior controle e compatibilidade.",
        "code": [
          {
            "description": "Exemplo 1: Implementação básica de smooth scroll para links internos.",
            "javascript": "function setupSmoothScroll() {\n  const links = document.querySelectorAll('a[href^=\"#\"]');\n  links.forEach(link => {\n    link.addEventListener('click', (e) => {\n      e.preventDefault();\n      const target = document.querySelector(link.getAttribute('href'));\n      target.scrollIntoView({ behavior: 'smooth' });\n    });\n  });\n}\nsetupSmoothScroll();"
          },
          {
            "description": "Exemplo 2: Smooth scroll com offset para compensar um cabeçalho fixo.",
            "javascript": "function setupSmoothScrollWithOffset() {\n  const links = document.querySelectorAll('a[href^=\"#\"]');\n  links.forEach(link => {\n    link.addEventListener('click', (e) => {\n      e.preventDefault();\n      const target = document.querySelector(link.getAttribute('href'));\n      const offset = 80; // Altura do cabeçalho fixo\n      const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - offset;\n      window.scrollTo({ top: targetPosition, behavior: 'smooth' });\n    });\n  });\n}\nsetupSmoothScrollWithOffset();"
          },
          {
            "description": "Exemplo 3: Rolar até o topo da página com smooth scroll ao clicar em um botão.",
            "javascript": "function scrollToTop() {\n  const button = document.querySelector('#toTopBtn');\n  button.addEventListener('click', () => {\n    window.scrollTo({ top: 0, behavior: 'smooth' });\n  });\n}\nscrollToTop();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "modal",
    "arrayId": "array-javascript-modal",
    "posts": [
      {
        "id": "23",
        "title": "Implementando um Modal",
        "content1": "Um modal é uma janela ou caixa de diálogo que aparece sobre o conteúdo principal da página, geralmente usada para exibir informações adicionais, formulários ou alertas, sem redirecionar o usuário para outra página. Modals são implementados com HTML, CSS e JavaScript: o HTML define a estrutura do modal, o CSS controla sua aparência e posicionamento (como `display: none` para ocultá-lo inicialmente), e o JavaScript gerencia a abertura e o fechamento, geralmente alternando a visibilidade com eventos de clique. Um modal típico inclui um botão para abri-lo, um botão para fechá-lo e um fundo escurecido (overlay) que bloqueia a interação com o conteúdo subjacente. Para acessibilidade, modals devem suportar fechamento com a tecla Esc e foco gerenciado para usuários de teclado, usando atributos ARIA como `role='dialog'`.",
        "code": [
          {
            "description": "Exemplo 1: Implementação básica de um modal com botões de abrir e fechar.",
            "javascript": "function setupModal() {\n  const modal = document.querySelector('#myModal');\n  const openBtn = document.querySelector('#openModal');\n  const closeBtn = document.querySelector('.close');\n  openBtn.addEventListener('click', () => {\n    modal.style.display = 'block';\n  });\n  closeBtn.addEventListener('click', () => {\n    modal.style.display = 'none';\n  });\n}\nsetupModal();"
          },
          {
            "description": "Exemplo 2: Fechando o modal ao clicar fora dele (no overlay).",
            "javascript": "function setupModalWithOverlay() {\n  const modal = document.querySelector('#myModal');\n  const openBtn = document.querySelector('#openModal');\n  const closeBtn = document.querySelector('.close');\n  openBtn.addEventListener('click', () => {\n    modal.style.display = 'block';\n  });\n  closeBtn.addEventListener('click', () => {\n    modal.style.display = 'none';\n  });\n  window.addEventListener('click', (e) => {\n    if (e.target === modal) {\n      modal.style.display = 'none';\n    }\n  });\n}\nsetupModalWithOverlay();"
          },
          {
            "description": "Exemplo 3: Fechando o modal com a tecla Esc para maior acessibilidade.",
            "javascript": "function setupModalWithEsc() {\n  const modal = document.querySelector('#myModal');\n  const openBtn = document.querySelector('#openModal');\n  const closeBtn = document.querySelector('.close');\n  openBtn.addEventListener('click', () => {\n    modal.style.display = 'block';\n  });\n  closeBtn.addEventListener('click', () => {\n    modal.style.display = 'none';\n  });\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape' && modal.style.display === 'block') {\n      modal.style.display = 'none';\n    }\n  });\n}\nsetupModalWithEsc();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "timers",
    "arrayId": "array-javascript-timers",
    "posts": [
      {
        "id": "24",
        "title": "Uso de setTimeout e setInterval",
        "content1": "JavaScript oferece dois métodos principais para trabalhar com temporizadores: `setTimeout()` e `setInterval()`. O método `setTimeout()` executa uma função ou trecho de código uma única vez após um atraso especificado (em milissegundos). Já o `setInterval()` executa uma função repetidamente em intervalos regulares até ser interrompido com `clearInterval()`. Ambos os métodos retornam um ID que pode ser usado para cancelar a execução com `clearTimeout()` ou `clearInterval()`. Esses temporizadores são assíncronos, ou seja, não bloqueiam a execução do restante do código, o que os torna úteis para tarefas como animações, atualizações periódicas ou atrasos intencionais. No entanto, deve-se ter cuidado com `setInterval()`, pois ele pode acumular execuções se a função demorar mais que o intervalo para ser executada.",
        "code": [
          {
            "description": "Exemplo 1: Uso de `setTimeout()` para exibir uma mensagem após 2 segundos.",
            "javascript": "function setupTimeout() {\n  setTimeout(() => {\n    console.log('Executado após 2 segundos');\n  }, 2000);\n}\nsetupTimeout();"
          },
          {
            "description": "Exemplo 2: Uso de `setInterval()` para exibir a hora atual a cada 3 segundos, com opção de parar.",
            "javascript": "function setupInterval() {\n  const intervalId = setInterval(() => {\n    const now = new Date();\n    console.log(`Hora atual: ${now.toLocaleTimeString()}`);\n  }, 3000);\n  setTimeout(() => clearInterval(intervalId), 10000); // Para após 10 segundos\n}\nsetupInterval();"
          },
          {
            "description": "Exemplo 3: Criando uma contagem regressiva com `setInterval()` e parando ao chegar a zero.",
            "javascript": "function countdown() {\n  let count = 5;\n  const intervalId = setInterval(() => {\n    console.log(`Contagem: ${count}`);\n    count--;\n    if (count < 0) {\n      clearInterval(intervalId);\n      console.log('Contagem finalizada!');\n    }\n  }, 1000);\n}\ncountdown();"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "operators",
    "arrayId": "array-javascript-operators",
    "posts": [
      {
        "id": "17",
        "title": "Operadores em JavaScript",
        "content1": "JavaScript oferece diversos tipos de operadores para realizar operações em valores e variáveis. Isso inclui operadores aritméticos (+, -, *, /, %), operadores de comparação (==, ===, !=, !==, >, <, >=, <=), operadores lógicos (&&, ||, !), operadores de atribuição (=, +=, -=, *=, /=) e operadores bit a bit (&, |, ^, ~, <<, >>, >>>). Cada operador tem sua própria precedência e associatividade.",
        "docLink": "Consulte aqui a documentação oficial - Operadores JavaScript",
        "code": [
          {
            "description": "Exemplo de operadores aritméticos e de comparação",
            "javascript": "// Operadores aritméticos\nlet soma = 5 + 3;      // 8\nlet subtracao = 10 - 4; // 6\nlet mult = 3 * 4;      // 12\nlet divisao = 15 / 3;  // 5\nlet modulo = 17 % 5;   // 2\n\n// Operadores de comparação\nconsole.log(5 === '5');  // false (comparação estrita)\nconsole.log(5 == '5');   // true (comparação com coerção)\nconsole.log(10 > 5);     // true\nconsole.log(3 <= 3);     // true"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "controlflow",
    "arrayId": "array-javascript-controlflow",
    "posts": [
      {
        "id": "18",
        "title": "Estruturas de Controle em JavaScript",
        "content1": "Estruturas de controle permitem que você controle o fluxo de execução do seu código. JavaScript oferece estruturas como if/else para tomada de decisões, switch para múltiplas condições, e loops (for, while, do...while) para repetição. Também inclui break e continue para controle mais fino dentro de loops, e try/catch para tratamento de erros.",
        "docLink": "Consulte aqui a documentação oficial - Estruturas de Controle JavaScript",
        "code": [
          {
            "description": "Exemplo de estruturas de controle",
            "javascript": "// if/else\nlet idade = 18;\nif (idade >= 18) {\n  console.log('Maior de idade');\n} else {\n  console.log('Menor de idade');\n}\n\n// switch\nlet dia = 'Segunda';\nswitch (dia) {\n  case 'Segunda':\n    console.log('Início da semana');\n    break;\n  case 'Sexta':\n    console.log('Fim da semana');\n    break;\n  default:\n    console.log('Meio da semana');\n}\n\n// for loop\nfor (let i = 0; i < 5; i++) {\n  if (i === 3) continue; // pula o 3\n  console.log(i);\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "loops",
    "arrayId": "array-javascript-loops",
    "posts": [
      {
        "id": "10",
        "title": "Loops em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/loops",
        "content1": "Loops são estruturas de controle que permitem repetir um bloco de código várias vezes. Em JavaScript, existem três tipos principais de loops: `for`, `while` e `do-while`. Cada um deles tem um propósito específico e é usado de acordo com a necessidade do desenvolvedor.",
        "code": [
          {
            "description": "Exemplo 1: Uso de um loop `for` para repetir um bloco de código um número determinado de vezes.",
            "javascript": "for (let i = 0; i < 5; i++) {\n  console.log(i);\n}\n// 0, 1, 2, 3, 4"
          },
          {
            "description": "Exemplo 2: Uso de um loop `while` para repetir um bloco de código até que uma condição seja atendida.",
            "javascript": "let i = 0;\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}\n// 0, 1, 2, 3, 4"
          },
          {
            "description": "Exemplo 3: Uso de um loop `do-while` para repetir um bloco de código até que uma condição seja atendida.",
            "javascript": "let i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 5);\n// 0, 1, 2, 3, 4"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "async",
    "arrayId": "array-javascript-async",
    "posts": [
      {
        "id": "14",
        "title": "Programação Assíncrona em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/async",
        "content1": "A programação assíncrona é fundamental em JavaScript, permitindo que operações demoradas sejam executadas sem bloquear o resto do código. JavaScript oferece várias formas de lidar com operações assíncronas: callbacks, Promises e async/await. Callbacks são funções passadas como argumentos para outras funções, que são executadas após a conclusão de uma operação. Promises são objetos que representam a eventual conclusão (ou falha) de uma operação assíncrona, oferecendo uma maneira mais elegante de lidar com callbacks aninhados. Async/await é uma sintaxe mais moderna que torna o código assíncrono parecer síncrono, facilitando a leitura e manutenção. O tratamento adequado de operações assíncronas é crucial para criar aplicações responsivas e eficientes.",
        "docLink": "Consulte aqui a documentação oficial - Programação Assíncrona JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Usando Promises para fazer uma requisição HTTP",
            "javascript": "// Fazendo uma requisição HTTP usando fetch (retorna uma Promise)\nfetch('https://api.exemplo.com/dados')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Erro:', error));\n\n// Criando uma Promise personalizada\nconst minhaPromise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const sucesso = true;\n    if (sucesso) {\n      resolve('Operação concluída!');\n    } else {\n      reject('Algo deu errado!');\n    }\n  }, 2000);\n});\n\nminhaPromise\n  .then(resultado => console.log(resultado))\n  .catch(erro => console.error(erro));"
          },
          {
            "description": "Exemplo 2: Usando async/await para código assíncrono mais limpo",
            "javascript": "async function buscarDados() {\n  try {\n    const response = await fetch('https://api.exemplo.com/dados');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Erro:', error);\n  }\n}\n\n// Função que usa async/await com múltiplas operações\nasync function processarDados() {\n  try {\n    const usuarios = await buscarUsuarios();\n    const posts = await buscarPosts(usuarios[0].id);\n    const comentarios = await buscarComentarios(posts[0].id);\n    return comentarios;\n  } catch (error) {\n    console.error('Erro no processamento:', error);\n  }\n}"
          },
          {
            "description": "Exemplo 3: Executando múltiplas Promises em paralelo",
            "javascript": "// Promise.all - espera todas as Promises serem resolvidas\nconst promises = [\n  fetch('https://api.exemplo.com/usuarios'),\n  fetch('https://api.exemplo.com/posts'),\n  fetch('https://api.exemplo.com/comentarios')\n];\n\nPromise.all(promises)\n  .then(responses => Promise.all(responses.map(res => res.json())))\n  .then(results => {\n    const [usuarios, posts, comentarios] = results;\n    console.log({ usuarios, posts, comentarios });\n  })\n  .catch(error => console.error('Erro:', error));\n\n// Promise.race - retorna a primeira Promise a ser resolvida\nPromise.race([\n  fetch('https://api1.exemplo.com/dados'),\n  fetch('https://api2.exemplo.com/dados')\n])\n  .then(response => response.json())\n  .then(data => console.log('Primeiro a responder:', data))\n  .catch(error => console.error('Erro:', error));"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "error",
    "arrayId": "array-javascript-error",
    "posts": [
      {
        "id": "15",
        "title": "Tratamento de Erros em JavaScript",
        "docUrl": "https://www.javascript.com/learn/javascript/error-handling",
        "content1": "O tratamento de erros é uma parte crucial da programação JavaScript, permitindo que os desenvolvedores lidem com situações inesperadas de forma elegante. JavaScript fornece o bloco try/catch para capturar e tratar erros, e a palavra-chave throw para lançar erros personalizados. O objeto Error e seus subclasses (como TypeError, ReferenceError, SyntaxError) fornecem informações sobre diferentes tipos de erros. Além disso, o bloco finally pode ser usado para executar código que deve ser executado independentemente de um erro ter ocorrido ou não. O tratamento adequado de erros é essencial para criar aplicações robustas e confiáveis, fornecendo feedback útil aos usuários e facilitando a depuração.",
        "docLink": "Consulte aqui a documentação oficial - Tratamento de Erros JavaScript",
        "code": [
          {
            "description": "Exemplo 1: Usando try/catch para tratamento básico de erros",
            "javascript": "function dividir(a, b) {\n  try {\n    if (b === 0) {\n      throw new Error('Divisão por zero não é permitida');\n    }\n    return a / b;\n  } catch (error) {\n    console.error('Erro:', error.message);\n    return null;\n  } finally {\n    console.log('Operação de divisão finalizada');\n  }\n}\n\nconsole.log(dividir(10, 2)); // 5\nconsole.log(dividir(10, 0)); // null"
          },
          {
            "description": "Exemplo 2: Criando e usando erros personalizados",
            "javascript": "// Definindo um erro personalizado\nclass ValidacaoError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidacaoError';\n  }\n}\n\nfunction validarUsuario(usuario) {\n  try {\n    if (!usuario.nome) {\n      throw new ValidacaoError('Nome é obrigatório');\n    }\n    if (!usuario.email) {\n      throw new ValidacaoError('Email é obrigatório');\n    }\n    if (!usuario.email.includes('@')) {\n      throw new ValidacaoError('Email inválido');\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof ValidacaoError) {\n      console.error('Erro de validação:', error.message);\n    } else {\n      console.error('Erro inesperado:', error);\n    }\n    return false;\n  }\n}"
          },
          {
            "description": "Exemplo 3: Tratamento de erros em código assíncrono",
            "javascript": "async function buscarDados() {\n  try {\n    const response = await fetch('https://api.exemplo.com/dados');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    if (error.name === 'TypeError') {\n      console.error('Erro de rede:', error.message);\n    } else {\n      console.error('Erro ao buscar dados:', error.message);\n    }\n    throw error; // Re-lança o erro para tratamento em nível superior\n  }\n}\n\n// Usando o tratamento de erros com Promises\nfetch('https://api.exemplo.com/dados')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => console.log(data))\n  .catch(error => console.error('Erro:', error.message));"
          }
        ]
      }
    ]
  }
]