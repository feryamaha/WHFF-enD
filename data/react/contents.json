[
  {
    "conceptId": "react",
    "arrayId": "array-react-react",
    "posts": [
      {
        "id": "1",
        "title": "React",
        "docUrl": "https://reactjs.org/",
        "content1": "React é uma biblioteca JavaScript para construção de interfaces de usuário. Desenvolvida pelo Facebook, é uma das bibliotecas mais populares para desenvolvimento front-end.",
        "content2": "React se destaca por sua abordagem baseada em componentes, que permite criar interfaces de usuário complexas a partir de pequenos blocos de código reutilizáveis.",
        "content3": "Uma das principais características do React é o Virtual DOM, uma representação em memória do DOM real. Quando os dados mudam, o React primeiro atualiza o Virtual DOM e depois compara com o DOM real para fazer apenas as alterações necessárias, resultando em uma interface mais rápida e eficiente. Além disso, o React utiliza um fluxo de dados unidirecional, o que torna o código mais previsível e fácil de depurar.",
        "code": [
          {
            "description": "Exemplo 1: Criando um componente React básico",
            "javascript": "import React from 'react';\n\nfunction App() {\n  return (\n    <div>\n      <h1>Olá, React!</h1>\n      <p>Bem-vindo ao meu primeiro componente React</p>\n    </div>\n  );\n}\n\nexport default App;"
          },
          {
            "description": "Exemplo 2: Usando props em um componente",
            "javascript": "function Welcome(props) {\n  return <h1>Olá, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "components",
    "arrayId": "array-react-components",
    "posts": [
      {
        "id": "2",
        "title": "Componentes React",
        "docUrl": "https://reactjs.org/docs/components-and-props.html",
        "content1": "Componentes são os blocos de construção básicos de qualquer aplicação React. Eles permitem dividir a UI em partes independentes e reutilizáveis.",
        "content2": "Cada componente deve seguir o princípio de responsabilidade única, focando em uma única funcionalidade. Isso torna o código mais fácil de manter e reutilizar. Os componentes podem receber dados através de props e manter seu próprio estado interno.",
        "content3": "A composição de componentes é uma técnica poderosa no React, permitindo criar interfaces complexas combinando componentes menores. Isso promove a reutilização de código e torna a aplicação mais modular e fácil de manter.",
        "code": [
          {
            "description": "Exemplo 1: Componente funcional",
            "javascript": "function Button(props) {\n  return (\n    <button onClick={props.onClick}>\n      {props.children}\n    </button>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Componente de classe",
            "javascript": "class Welcome extends React.Component {\n  render() {\n    return <h1>Olá, {this.props.name}</h1>;\n  }\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "componentes",
    "arrayId": "Array-react-componentes",
    "posts": [
      {
        "id": "1",
        "title": "Post 1",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      },
      {
        "id": "2",
        "title": "Post 2",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      }
    ]
  },
  {
    "conceptId": "state",
    "arrayId": "array-react-state",
    "posts": [
      {
        "id": "4",
        "title": "Estado em React",
        "docUrl": "https://reactjs.org/docs/state-and-lifecycle.html",
        "content1": "O estado em React é um objeto que contém dados que podem mudar ao longo do tempo e afetar o comportamento do componente.",
        "content2": "Em componentes funcionais, o estado é gerenciado usando o Hook useState. O useState retorna um array com dois elementos: o valor atual do estado e uma função para atualizá-lo. É importante notar que as atualizações de estado são assíncronas e o React pode agrupar várias atualizações para melhor performance.",
        "content3": "O estado deve ser usado para dados que podem mudar e que afetam a renderização do componente. É importante manter o estado o mais simples possível e evitar duplicação de dados. Para compartilhar estado entre componentes, você pode usar o Context API ou elevar o estado para um componente pai comum.",
        "code": [
          {
            "description": "Exemplo 1: Usando useState em um componente funcional",
            "javascript": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Você clicou {count} vezes</p>\n      <button onClick={() => setCount(count + 1)}>\n        Incrementar\n      </button>\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Estado com objeto complexo",
            "javascript": "function UserProfile() {\n  const [user, setUser] = useState({\n    name: 'João',\n    age: 25,\n    email: 'joao@email.com'\n  });\n\n  const updateName = (newName) => {\n    setUser(prevUser => ({\n      ...prevUser,\n      name: newName\n    }));\n  };\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Idade: {user.age}</p>\n      <p>Email: {user.email}</p>\n      <button onClick={() => updateName('Maria')}>\n        Mudar Nome\n      </button>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "usestate",
    "arrayId": "array-react-usestate",
    "posts": [
      {
        "id": "1",
        "title": "useState no React",
        "content1": "O useState é um Hook fundamental do React que permite adicionar estado a componentes funcionais. Ele retorna um array com dois elementos: o valor atual do estado e uma função para atualizá-lo. O useState pode ser usado com qualquer tipo de dado: números, strings, booleanos, arrays, objetos, etc.",
        "content2": "Quando você chama a função de atualização do estado, o React agenda uma nova renderização do componente. Se o novo valor do estado depende do valor anterior, você deve passar uma função para o setter que recebe o valor anterior como argumento. Isso garante que você sempre terá acesso ao valor mais recente do estado.",
        "content3": "É possível ter múltiplos estados em um componente usando useState várias vezes. Cada chamada de useState é independente e mantém seu próprio estado. Para estados complexos ou relacionados, considere usar useReducer ou dividir em múltiplos componentes.",
        "code": [
          {
            "description": "Exemplo 1: useState com diferentes tipos de dados",
            "javascript": "function UserForm() {\n  const [name, setName] = useState('');\n  const [age, setAge] = useState(0);\n  const [isAdmin, setIsAdmin] = useState(false);\n  const [hobbies, setHobbies] = useState([]);\n\n  const handleAddHobby = (hobby) => {\n    setHobbies(prevHobbies => [...prevHobbies, hobby]);\n  };\n\n  return (\n    <div>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n        placeholder=\"Nome\"\n      />\n      <input\n        type=\"number\"\n        value={age}\n        onChange={e => setAge(Number(e.target.value))}\n        placeholder=\"Idade\"\n      />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isAdmin}\n          onChange={e => setIsAdmin(e.target.checked)}\n        />\n        É administrador?\n      </label>\n      <button onClick={() => handleAddHobby('Novo hobby')}>\n        Adicionar Hobby\n      </button>\n      <ul>\n        {hobbies.map((hobby, index) => (\n          <li key={index}>{hobby}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: useState com objetos e atualizações funcionais",
            "javascript": "function ShoppingCart() {\n  const [cart, setCart] = useState({\n    items: [],\n    total: 0\n  });\n\n  const addItem = (item) => {\n    setCart(prevCart => ({\n      items: [...prevCart.items, item],\n      total: prevCart.total + item.price\n    }));\n  };\n\n  const removeItem = (itemId) => {\n    setCart(prevCart => {\n      const item = prevCart.items.find(i => i.id === itemId);\n      return {\n        items: prevCart.items.filter(i => i.id !== itemId),\n        total: prevCart.total - (item ? item.price : 0)\n      };\n    });\n  };\n\n  return (\n    <div>\n      <h2>Carrinho de Compras</h2>\n      <p>Total: R$ {cart.total.toFixed(2)}</p>\n      <ul>\n        {cart.items.map(item => (\n          <li key={item.id}>\n            {item.name} - R$ {item.price.toFixed(2)}\n            <button onClick={() => removeItem(item.id)}>\n              Remover\n            </button>\n          </li>\n        ))}\n      </ul>\n      <button\n        onClick={() => addItem({\n          id: Date.now(),\n          name: 'Produto',\n          price: 29.99\n        })}\n      >\n        Adicionar Produto\n      </button>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "props",
    "arrayId": "array-react-props",
    "posts": [
      {
        "id": "3",
        "title": "Props em React",
        "docUrl": "https://reactjs.org/docs/components-and-props.html",
        "content1": "Props (propriedades) são uma forma de passar dados de um componente pai para um componente filho em React.",
        "content2": "Para passar props para um componente, você usa a sintaxe similar a atributos HTML. O componente filho recebe as props como um objeto único, que pode ser desestruturado para facilitar o acesso aos valores. É importante lembrar que as props são imutáveis dentro do componente filho - um componente nunca deve modificar suas próprias props.",
        "content3": "As props são fundamentais para a comunicação entre componentes no React. Elas permitem que você crie componentes reutilizáveis que podem ser configurados de diferentes maneiras. Além disso, as props são uma parte essencial do fluxo de dados unidirecional do React, onde os dados fluem do componente pai para o filho.",
        "code": [
          {
            "description": "Exemplo 1: Passando e usando props básicas",
            "javascript": "function Welcome(props) {\n  return <h1>Olá, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Props com desestruturação e valores padrão",
            "javascript": "function Button({ text = 'Clique aqui', onClick, disabled = false }) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className=\"btn\"\n    >\n      {text}\n    </button>\n  );\n}\n\nfunction App() {\n  const handleClick = () => {\n    console.log('Botão clicado!');\n  };\n\n  return (\n    <div>\n      <Button text=\"Salvar\" onClick={handleClick} />\n      <Button onClick={handleClick} disabled={true} />\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "ciclo-de-vida",
    "arrayId": "Array-react-ciclo-de-vida",
    "posts": [
      {
        "id": "1",
        "title": "Post 1",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      },
      {
        "id": "2",
        "title": "Post 2",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      }
    ]
  },
  {
    "conceptId": "eventos",
    "arrayId": "Array-react-eventos",
    "posts": [
      {
        "id": "1",
        "title": "Post 1",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      },
      {
        "id": "2",
        "title": "Post 2",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      }
    ]
  },
  {
    "conceptId": "renderizacao-condicional",
    "arrayId": "Array-react-renderizacao-condicional",
    "posts": [
      {
        "id": "1",
        "title": "Post 1",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      },
      {
        "id": "2",
        "title": "Post 2",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      }
    ]
  },
  {
    "conceptId": "listas-e-chaves",
    "arrayId": "Array-react-listas-e-chaves",
    "posts": [
      {
        "id": "1",
        "title": "Post 1",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      },
      {
        "id": "2",
        "title": "Post 2",
        "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt."
      }
    ]
  },
  {
    "conceptId": "hooks",
    "arrayId": "array-react-hooks",
    "posts": [
      {
        "id": "5",
        "title": "Hooks em React",
        "docUrl": "https://reactjs.org/docs/hooks-intro.html",
        "content1": "Hooks são funções que permitem usar estado e outras características do React em componentes funcionais.",
        "content2": "Existem vários Hooks built-in no React, como useState, useEffect, useContext, useRef, useMemo e useCallback. Cada Hook tem um propósito específico e segue a convenção de nomenclatura 'use' no início. Além disso, você pode criar seus próprios Hooks personalizados para encapsular lógica reutilizável.",
        "content3": "Os Hooks devem ser chamados apenas no nível superior dos componentes funcionais ou de outros Hooks personalizados. Não devem ser chamados dentro de loops, condições ou funções aninhadas. Essa regra garante que os Hooks sejam chamados na mesma ordem em cada renderização.",
        "code": [
          {
            "description": "Exemplo 1: Hooks básicos (useState e useEffect)",
            "javascript": "import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    document.title = `Você clicou ${count} vezes`;\n  }, [count]);\n\n  useEffect(() => {\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, []);\n\n  return (\n    <div>\n      <p>Você clicou {count} vezes</p>\n      <button onClick={() => setCount(count + 1)}>\n        Clique aqui\n      </button>\n      {data && <p>Dados carregados: {JSON.stringify(data)}</p>}\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Hook personalizado",
            "javascript": "function useWindowSize() {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    function handleResize() {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return size;\n}\n\nfunction App() {\n  const { width, height } = useWindowSize();\n\n  return (\n    <div>\n      <p>Largura da janela: {width}px</p>\n      <p>Altura da janela: {height}px</p>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "context",
    "arrayId": "array-react-context",
    "posts": [
      {
        "id": "1",
        "title": "Context API no React",
        "content1": "A Context API é um recurso do React que permite compartilhar dados entre componentes sem a necessidade de passar props manualmente através de cada nível da árvore de componentes. É especialmente útil para dados globais como temas, preferências do usuário, autenticação e outros dados que precisam ser acessados por muitos componentes.",
        "content2": "Para usar a Context API, você precisa criar um contexto usando React.createContext(), fornecer um valor através do Provider e consumir o valor em qualquer componente filho usando o Hook useContext. O Provider aceita um valor que será compartilhado com todos os componentes filhos, e o valor pode ser atualizado dinamicamente.",
        "content3": "Embora a Context API seja poderosa, ela deve ser usada com moderação. Não é recomendado usar Context para dados que mudam frequentemente, pois pode causar re-renderizações desnecessárias. Para esses casos, é melhor usar uma solução de gerenciamento de estado como Redux ou uma combinação de Context com outros Hooks.",
        "code": [
          {
            "description": "Exemplo 1: Context básico com tema",
            "javascript": "import React, { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const [isDarkMode, setIsDarkMode] = useState(false);\n\n  const toggleTheme = () => {\n    setIsDarkMode(prev => !prev);\n  };\n\n  return (\n    <ThemeContext.Provider value={{ isDarkMode, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction useTheme() {\n  return useContext(ThemeContext);\n}\n\nfunction ThemedButton() {\n  const { isDarkMode, toggleTheme } = useTheme();\n\n  return (\n    <button\n      onClick={toggleTheme}\n      style={{\n        backgroundColor: isDarkMode ? '#333' : '#fff',\n        color: isDarkMode ? '#fff' : '#333'\n      }}\n    >\n      Alternar Tema\n    </button>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Context com múltiplos valores",
            "javascript": "const UserContext = createContext();\n\nexport function UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Simular carregamento de usuário\n    fetchUser().then(userData => {\n      setUser(userData);\n      setLoading(false);\n    });\n  }, []);\n\n  const value = {\n    user,\n    loading,\n    login: (userData) => setUser(userData),\n    logout: () => setUser(null)\n  };\n\n  return (\n    <UserContext.Provider value={value}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nfunction UserProfile() {\n  const { user, loading } = useContext(UserContext);\n\n  if (loading) return <div>Carregando...</div>;\n  if (!user) return <div>Por favor, faça login</div>;\n\n  return (\n    <div>\n      <h2>Bem-vindo, {user.name}!</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "performance",
    "arrayId": "array-react-performance",
    "posts": [
      {
        "id": "1",
        "title": "Performance no React",
        "content1": "A performance é um aspecto crucial no desenvolvimento de aplicações React. O React já possui otimizações internas como o Virtual DOM, mas existem várias técnicas e ferramentas que podem ser utilizadas para melhorar ainda mais o desempenho da aplicação. Isso inclui o uso de memoização, lazy loading, code splitting e otimização de re-renderizações.",
        "content2": "O React oferece vários hooks e componentes para otimização de performance, como React.memo, useMemo, useCallback e Suspense. O React.memo evita re-renderizações desnecessárias de componentes, useMemo memoiza valores computados, useCallback memoiza funções, e Suspense permite carregar componentes de forma lazy. Além disso, ferramentas como o React DevTools Profiler ajudam a identificar gargalos de performance.",
        "content3": "Outras técnicas importantes incluem a virtualização de listas longas, otimização de imagens, redução do tamanho do bundle, e implementação de estratégias de cache. É fundamental monitorar métricas de performance como First Contentful Paint (FCP), Time to Interactive (TTI) e Largest Contentful Paint (LCP) para garantir uma boa experiência do usuário.",
        "code": [
          {
            "description": "Exemplo 1: Otimização com React.memo e useCallback",
            "javascript": "const ExpensiveComponent = React.memo(function ExpensiveComponent({ data, onItemClick }) {\n  console.log('Renderizando ExpensiveComponent');\n  return (\n    <ul>\n      {data.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n\nfunction ParentComponent() {\n  const [data, setData] = useState([]);\n\n  const handleItemClick = useCallback((id) => {\n    console.log('Item clicado:', id);\n  }, []);\n\n  useEffect(() => {\n    // Simular carregamento de dados\n    fetchData().then(setData);\n  }, []);\n\n  return (\n    <div>\n      <ExpensiveComponent\n        data={data}\n        onItemClick={handleItemClick}\n      />\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Lazy loading e Code Splitting",
            "javascript": "import React, { Suspense, lazy } from 'react';\n\n// Lazy loading de componentes\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Settings = lazy(() => import('./Settings'));\nconst Profile = lazy(() => import('./Profile'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Routes>\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/settings\" element={<Settings />} />\n          <Route path=\"/profile\" element={<Profile />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n\n// Componente de loading\nfunction LoadingSpinner() {\n  return <div>Carregando...</div>;\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "useeffect",
    "arrayId": "array-react-useeffect",
    "posts": [
      {
        "id": "1",
        "title": "useEffect no React",
        "content1": "O useEffect é um Hook que permite executar efeitos colaterais em componentes funcionais. Efeitos colaterais podem incluir requisições de dados, subscrições, ou manipulação manual do DOM. O useEffect é executado após cada renderização do componente, mas pode ser configurado para executar apenas quando certos valores mudam.",
        "content2": "O useEffect aceita dois argumentos: uma função de callback que contém o código do efeito, e um array de dependências opcional. Se o array de dependências for omitido, o efeito será executado após cada renderização. Se for um array vazio, o efeito será executado apenas uma vez, após a primeira renderização. Se contiver valores, o efeito será executado quando qualquer um desses valores mudar.",
        "content3": "A função de callback do useEffect pode retornar uma função de limpeza (cleanup). Esta função é executada antes do próximo efeito e quando o componente é desmontado. Isso é útil para cancelar subscrições, limpar timers, ou remover event listeners.",
        "code": [
          {
            "description": "Exemplo 1: useEffect com diferentes dependências",
            "javascript": "function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // Executa apenas uma vez na montagem\n  useEffect(() => {\n    console.log('Componente montado');\n  }, []);\n\n  // Executa quando userId muda\n  useEffect(() => {\n    setLoading(true);\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      });\n  }, [userId]);\n\n  // Executa em toda renderização\n  useEffect(() => {\n    console.log('Dados atualizados:', { user, loading });\n  });\n\n  if (loading) return <div>Carregando...</div>;\n  if (!user) return <div>Usuário não encontrado</div>;\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: useEffect com cleanup",
            "javascript": "function ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    const connection = createConnection(roomId);\n    connection.connect();\n\n    const handleMessage = (message) => {\n      setMessages(prev => [...prev, message]);\n    };\n\n    connection.on('message', handleMessage);\n\n    // Função de cleanup\n    return () => {\n      connection.off('message', handleMessage);\n      connection.disconnect();\n    };\n  }, [roomId]);\n\n  return (\n    <div>\n      <h2>Sala: {roomId}</h2>\n      <ul>\n        {messages.map(msg => (\n          <li key={msg.id}>{msg.text}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Exemplo de uso com window event listener\nfunction WindowSize() {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return (\n    <div>\n      <p>Largura: {size.width}px</p>\n      <p>Altura: {size.height}px</p>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "routing",
    "arrayId": "array-react-routing",
    "posts": [
      {
        "id": "1",
        "title": "Roteamento no React",
        "content1": "O roteamento é uma parte essencial de aplicações React modernas, permitindo a navegação entre diferentes componentes/páginas sem recarregar a página inteira. A biblioteca mais popular para roteamento no React é o React Router, que fornece uma API declarativa e poderosa para gerenciar rotas em aplicações React.",
        "content2": "O React Router oferece vários componentes principais como BrowserRouter, Routes, Route e Link. O BrowserRouter envolve toda a aplicação, o Routes define o container para as rotas, o Route define uma rota individual e o Link cria links de navegação. Além disso, o React Router fornece hooks como useNavigate e useParams para programaticamente navegar e acessar parâmetros de URL.",
        "content3": "O React Router suporta recursos avançados como rotas aninhadas, rotas protegidas, parâmetros de URL, queries strings e navegação programática. Também oferece suporte a diferentes tipos de roteamento como hash routing e memory routing, úteis para diferentes cenários de deploy e teste.",
        "code": [
          {
            "description": "Exemplo 1: Configuração básica de rotas",
            "javascript": "import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">Sobre</Link>\n        <Link to=\"/users\">Usuários</Link>\n      </nav>\n\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/users\" element={<Users />} />\n        <Route path=\"/users/:id\" element={<UserProfile />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Rotas aninhadas e navegação programática",
            "javascript": "function Users() {\n  const navigate = useNavigate();\n  const { id } = useParams();\n\n  return (\n    <Routes>\n      <Route path=\"/\" element={<UserList />} />\n      <Route path=\"/:id\" element={<UserProfile />} />\n    </Routes>\n  );\n}\n\nfunction UserList() {\n  const navigate = useNavigate();\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    fetchUsers().then(data => setUsers(data));\n  }, []);\n\n  return (\n    <div>\n      <h2>Lista de Usuários</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <button onClick={() => navigate(`/users/${user.id}`)}>\n              {user.name}\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "forms",
    "arrayId": "array-react-forms",
    "posts": [
      {
        "id": "1",
        "title": "Formulários no React",
        "content1": "Formulários são uma parte essencial de muitas aplicações web, e o React oferece uma maneira poderosa de trabalhar com eles. O React suporta tanto formulários controlados quanto não controlados, sendo os formulários controlados a abordagem mais comum e recomendada.",
        "content2": "Em formulários controlados, o React controla o valor dos elementos de entrada através do estado. Cada elemento de formulário tem um valor que é controlado pelo React e uma função de callback para atualizar esse valor. Isso permite validação em tempo real, formatação de entrada e manipulação de dados mais precisa.",
        "content3": "Para formulários mais complexos, bibliotecas como Formik e React Hook Form podem ser utilizadas. Estas bibliotecas fornecem recursos adicionais como validação, gerenciamento de erros, submissão de formulários e integração com APIs de backend. Elas também ajudam a reduzir a quantidade de código boilerplate necessário.",
        "code": [
          {
            "description": "Exemplo 1: Formulário controlado básico",
            "javascript": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [formData, setFormData] = useState({\n    email: '',\n    password: ''\n  });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: value\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Dados do formulário:', formData);\n    // Lógica de submissão aqui\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Email:</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          required\n        />\n      </div>\n      <div>\n        <label>Senha:</label>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          required\n        />\n      </div>\n      <button type=\"submit\">Entrar</button>\n    </form>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Formulário com Formik e Yup",
            "javascript": "import { Formik, Form, Field, ErrorMessage } from 'formik';\nimport * as Yup from 'yup';\n\nconst validationSchema = Yup.object({\n  name: Yup.string()\n    .min(2, 'Muito curto!')\n    .max(50, 'Muito longo!')\n    .required('Obrigatório'),\n  email: Yup.string()\n    .email('Email inválido')\n    .required('Obrigatório'),\n  age: Yup.number()\n    .positive('Idade deve ser positiva')\n    .integer('Idade deve ser um número inteiro')\n    .required('Obrigatório')\n});\n\nfunction RegistrationForm() {\n  return (\n    <Formik\n      initialValues={{ name: '', email: '', age: '' }}\n      validationSchema={validationSchema}\n      onSubmit={(values, { setSubmitting }) => {\n        setTimeout(() => {\n          console.log(values);\n          setSubmitting(false);\n        }, 400);\n      }}\n    >\n      {({ isSubmitting }) => (\n        <Form>\n          <div>\n            <Field name=\"name\" placeholder=\"Nome\" />\n            <ErrorMessage name=\"name\" component=\"div\" />\n          </div>\n\n          <div>\n            <Field name=\"email\" type=\"email\" placeholder=\"Email\" />\n            <ErrorMessage name=\"email\" component=\"div\" />\n          </div>\n\n          <div>\n            <Field name=\"age\" type=\"number\" placeholder=\"Idade\" />\n            <ErrorMessage name=\"age\" component=\"div\" />\n          </div>\n\n          <button type=\"submit\" disabled={isSubmitting}>\n            Enviar\n          </button>\n        </Form>\n      )}\n    </Formik>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "events",
    "arrayId": "array-react-events",
    "posts": [
      {
        "id": "1",
        "title": "Eventos no React",
        "content1": "O React fornece uma maneira consistente de lidar com eventos em componentes, usando uma sintaxe similar aos eventos HTML nativos, mas com algumas diferenças importantes. Os eventos no React são nomeados usando camelCase (ex: onClick em vez de onclick) e são passados como funções em vez de strings.",
        "content2": "O React usa um sistema de delegação de eventos, onde todos os eventos são delegados para o elemento raiz do documento. Isso melhora a performance e reduz o uso de memória. Além disso, o React normaliza os eventos entre diferentes navegadores, garantindo um comportamento consistente.",
        "content3": "Para prevenir o comportamento padrão de um evento, você deve chamar explicitamente preventDefault(). Além disso, ao passar funções de evento como props, é importante considerar o uso de useCallback para evitar re-renderizações desnecessárias e possíveis problemas de performance.",
        "code": [
          {
            "description": "Exemplo 1: Manipuladores de eventos básicos",
            "javascript": "function Button() {\n  const handleClick = (e) => {\n    e.preventDefault();\n    console.log('Botão clicado!');\n  };\n\n  const handleMouseEnter = () => {\n    console.log('Mouse entrou no botão');\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      onMouseEnter={handleMouseEnter}\n      className=\"btn\"\n    >\n      Clique aqui\n    </button>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Eventos com parâmetros e useCallback",
            "javascript": "function TodoList() {\n  const [todos, setTodos] = useState([]);\n\n  const handleAddTodo = useCallback((text) => {\n    setTodos(prev => [...prev, { id: Date.now(), text }]);\n  }, []);\n\n  const handleKeyPress = useCallback((e) => {\n    if (e.key === 'Enter') {\n      handleAddTodo(e.target.value);\n      e.target.value = '';\n    }\n  }, [handleAddTodo]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Adicionar tarefa\"\n        onKeyPress={handleKeyPress}\n      />\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            {todo.text}\n            <button\n              onClick={() => setTodos(prev =>\n                prev.filter(t => t.id !== todo.id)\n              )}\n            >\n              Remover\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "lifecycle",
    "arrayId": "array-react-lifecycle",
    "posts": [
      {
        "id": "1",
        "title": "Ciclo de Vida no React",
        "content1": "O ciclo de vida de um componente React descreve as diferentes fases pelas quais um componente passa, desde sua criação até sua destruição. Em componentes de classe, esses ciclos são gerenciados através de métodos específicos como componentDidMount, componentDidUpdate e componentWillUnmount.",
        "content2": "Com a introdução dos Hooks, especialmente o useEffect, o gerenciamento do ciclo de vida em componentes funcionais tornou-se mais simples e flexível. O useEffect pode simular todos os comportamentos dos métodos de ciclo de vida de classe, permitindo executar efeitos colaterais em diferentes momentos do ciclo de vida do componente.",
        "content3": "É importante entender o ciclo de vida para gerenciar adequadamente recursos como inscrições em eventos, requisições de dados e limpeza de memória. O uso correto dos métodos de ciclo de vida ou do useEffect ajuda a evitar memory leaks e garante que os recursos sejam gerenciados apropriadamente.",
        "code": [
          {
            "description": "Exemplo 1: Ciclo de vida em componente de classe",
            "javascript": "class UserProfile extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true\n    };\n  }\n\n  componentDidMount() {\n    this.fetchUser();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser();\n    }\n  }\n\n  componentWillUnmount() {\n    // Limpeza de recursos\n    this.isSubscribed = false;\n  }\n\n  fetchUser = async () => {\n    try {\n      const response = await fetch(`/api/users/${this.props.userId}`);\n      const data = await response.json();\n      if (this.isSubscribed) {\n        this.setState({ user: data, loading: false });\n      }\n    } catch (error) {\n      console.error('Erro ao buscar usuário:', error);\n    }\n  };\n\n  render() {\n    if (this.state.loading) return <div>Carregando...</div>;\n    if (!this.state.user) return <div>Usuário não encontrado</div>;\n\n    return (\n      <div>\n        <h2>{this.state.user.name}</h2>\n        <p>Email: {this.state.user.email}</p>\n      </div>\n    );\n  }\n}"
          },
          {
            "description": "Exemplo 2: Ciclo de vida com Hooks",
            "javascript": "function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    let isSubscribed = true;\n\n    async function fetchUser() {\n      try {\n        const response = await fetch(`/api/users/${userId}`);\n        const data = await response.json();\n        if (isSubscribed) {\n          setUser(data);\n          setLoading(false);\n        }\n      } catch (error) {\n        console.error('Erro ao buscar usuário:', error);\n      }\n    }\n\n    fetchUser();\n\n    return () => {\n      isSubscribed = false;\n    };\n  }, [userId]);\n\n  if (loading) return <div>Carregando...</div>;\n  if (!user) return <div>Usuário não encontrado</div>;\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "conditional",
    "arrayId": "array-react-conditional",
    "posts": [
      {
        "id": "1",
        "title": "Renderização Condicional no React",
        "content1": "A renderização condicional é uma técnica poderosa no React que permite mostrar ou esconder elementos com base em condições específicas. Existem várias maneiras de implementar renderização condicional, incluindo operadores ternários, operadores lógicos && e ||, e declarações if/else.",
        "content2": "A renderização condicional é frequentemente usada para mostrar diferentes interfaces com base no estado do usuário, carregamento de dados, ou outras condições da aplicação. É importante considerar a performance ao usar renderização condicional, especialmente em listas grandes ou componentes complexos.",
        "content3": "Além da renderização condicional básica, o React também oferece recursos como renderização de listas com keys, renderização de múltiplos elementos usando fragments, e renderização de portais para renderizar conteúdo em diferentes partes do DOM.",
        "code": [
          {
            "description": "Exemplo 1: Renderização condicional básica",
            "javascript": "function UserGreeting({ isLoggedIn, username }) {\n  if (isLoggedIn) {\n    return <h1>Bem-vindo de volta, {username}!</h1>;\n  }\n  return <h1>Por favor, faça login</h1>;\n}\n\nfunction Notification({ count }) {\n  return (\n    <div>\n      {count > 0 && <span className=\"badge\">{count}</span>}\n      <button>Notificações</button>\n    </div>\n  );\n}\n\nfunction LoadingState({ isLoading, data }) {\n  return (\n    <div>\n      {isLoading ? (\n        <div>Carregando...</div>\n      ) : data ? (\n        <div>Dados carregados: {data}</div>\n      ) : (\n        <div>Nenhum dado disponível</div>\n      )}\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Renderização condicional avançada",
            "javascript": "function UserDashboard({ user, permissions }) {\n  const canEdit = permissions.includes('edit');\n  const canDelete = permissions.includes('delete');\n  const isAdmin = permissions.includes('admin');\n\n  return (\n    <div className=\"dashboard\">\n      <header>\n        <h1>Dashboard do Usuário</h1>\n        {isAdmin && <AdminControls />}\n      </header>\n\n      <main>\n        <section className=\"user-info\">\n          <h2>Informações do Usuário</h2>\n          <p>Nome: {user.name}</p>\n          <p>Email: {user.email}</p>\n          <div className=\"actions\">\n            {canEdit && (\n              <button onClick={() => handleEdit(user.id)}>\n                Editar\n              </button>\n            )}\n            {canDelete && (\n              <button onClick={() => handleDelete(user.id)}>\n                Excluir\n              </button>\n            )}\n          </div>\n        </section>\n\n        <section className=\"user-stats\">\n          <h2>Estatísticas</h2>\n          {user.stats ? (\n            <StatsDisplay stats={user.stats} />\n          ) : (\n            <p>Nenhuma estatística disponível</p>\n          )}\n        </section>\n      </main>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "lists",
    "arrayId": "array-react-lists",
    "posts": [
      {
        "id": "1",
        "title": "Listas e Keys no React",
        "content1": "O React oferece uma maneira eficiente de renderizar listas de elementos usando o método map() do JavaScript. Cada elemento em uma lista deve ter uma prop key única, que ajuda o React a identificar quais itens foram alterados, adicionados ou removidos. As keys devem ser estáveis, previsíveis e únicas entre os elementos irmãos.",
        "content2": "Para listas grandes ou que mudam frequentemente, o React fornece componentes especializados como FlatList (React Native) ou virtualização com react-window ou react-virtualized. Estes componentes ajudam a melhorar a performance renderizando apenas os itens visíveis na tela.",
        "content3": "Ao trabalhar com listas, é importante considerar a performance e a experiência do usuário. Isso inclui lidar com carregamento de dados, estados de erro, atualizações otimistas e feedback visual durante operações de lista. Além disso, é importante implementar paginação ou carregamento infinito para grandes conjuntos de dados.",
        "code": [
          {
            "description": "Exemplo 1: Renderização básica de lista",
            "javascript": "function TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={() => handleToggle(todo.id)}\n          />\n          <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            {todo.text}\n          </span>\n          <button onClick={() => handleDelete(todo.id)}>Deletar</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Exemplo de dados\nconst todos = [\n  { id: 1, text: 'Aprender React', completed: true },\n  { id: 2, text: 'Construir um app', completed: false },\n  { id: 3, text: 'Publicar o app', completed: false }\n];"
          },
          {
            "description": "Exemplo 2: Lista com virtualização e paginação",
            "javascript": "import { FixedSizeList } from 'react-window';\n\nfunction VirtualizedList({ items, loadMore }) {\n  const Row = ({ index, style }) => {\n    const item = items[index];\n    return (\n      <div style={style} className=\"list-item\">\n        <h3>{item.title}</h3>\n        <p>{item.description}</p>\n      </div>\n    );\n  };\n\n  return (\n    <div>\n      <FixedSizeList\n        height={400}\n        width={600}\n        itemCount={items.length}\n        itemSize={100}\n        onEndReached={loadMore}\n        onEndReachedThreshold={0.5}\n      >\n        {Row}\n      </FixedSizeList>\n    </div>\n  );\n}\n\nfunction PaginatedList() {\n  const [items, setItems] = useState([]);\n  const [page, setPage] = useState(1);\n  const [loading, setLoading] = useState(false);\n\n  const loadMore = async () => {\n    if (loading) return;\n    setLoading(true);\n    try {\n      const newItems = await fetchItems(page);\n      setItems(prev => [...prev, ...newItems]);\n      setPage(prev => prev + 1);\n    } catch (error) {\n      console.error('Erro ao carregar itens:', error);\n    }\n  };\n\n  return (\n    <div>\n      <VirtualizedList items={items} loadMore={loadMore} />\n      {loading && <div>Carregando mais itens...</div>}\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "refs",
    "arrayId": "array-react-refs",
    "posts": [
      {
        "id": "1",
        "title": "Refs no React",
        "content1": "Refs são uma forma de acessar diretamente elementos DOM ou instâncias de componentes React. Elas são úteis quando você precisa manipular o DOM diretamente, integrar com bibliotecas de terceiros que precisam de acesso ao DOM, ou gerenciar foco, seleção de texto ou reprodução de mídia. As refs são criadas usando o hook useRef em componentes funcionais ou React.createRef() em componentes de classe.",
        "content2": "As refs são especialmente úteis para casos que não podem ser resolvidos declarativamente, como gerenciar foco, seleção de texto, ou integração com bibliotecas DOM. No entanto, é importante usar refs com moderação, pois o uso excessivo pode levar a código imperativo e difícil de manter. Em geral, você deve tentar resolver problemas de forma declarativa antes de recorrer às refs.",
        "content3": "O React também oferece refs encaminhadas (forwardRef) que permitem passar refs através de componentes para acessar elementos DOM aninhados. Isso é útil para componentes de ordem superior (HOCs) e bibliotecas de componentes que precisam expor elementos DOM internos para seus consumidores.",
        "code": [
          {
            "description": "Exemplo 1: Uso básico de refs",
            "javascript": "function TextInputWithFocusButton() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <input\n        ref={inputRef}\n        type=\"text\"\n        placeholder=\"Digite algo...\"\n      />\n      <button onClick={handleClick}>\n        Focar no input\n      </button>\n    </div>\n  );\n}\n\n// Exemplo com componente de classe\nclass AutoFocusTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef();\n  }\n\n  componentDidMount() {\n    this.textInput.current.focus();\n  }\n\n  render() {\n    return <input ref={this.textInput} type=\"text\" />;\n  }\n}"
          },
          {
            "description": "Exemplo 2: Refs encaminhadas (forwardRef)",
            "javascript": "const FancyInput = React.forwardRef((props, ref) => {\n  return (\n    <input\n      ref={ref}\n      className=\"fancy-input\"\n      {...props}\n    />\n  );\n});\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // O input será focado quando o componente montar\n    inputRef.current.focus();\n  }, []);\n\n  return (\n    <div>\n      <FancyInput\n        ref={inputRef}\n        placeholder=\"Digite algo...\"\n      />\n      <button onClick={() => inputRef.current.focus()}>\n        Focar no input\n      </button>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "tests",
    "arrayId": "array-react-tests",
    "posts": [
      {
        "id": "1",
        "title": "Testes no React",
        "content1": "Os testes são uma parte essencial do desenvolvimento React, garantindo que os componentes funcionem conforme esperado e ajudando a prevenir regressões. O React possui uma biblioteca oficial de testes chamada React Testing Library, que promove boas práticas de teste focando no comportamento do usuário e não na implementação.",
        "content2": "Existem diferentes tipos de testes em aplicações React: testes de componentes (unitários), testes de integração, testes end-to-end e testes de snapshot. O Jest é o test runner padrão usado com React, oferecendo recursos como mocks, snapshots e cobertura de código. Além disso, ferramentas como Cypress e Playwright são populares para testes end-to-end.",
        "content3": "Ao escrever testes, é importante seguir princípios como testar o comportamento e não a implementação, usar queries que refletem como os usuários interagem com a aplicação, e manter os testes simples e manuteníveis. O React Testing Library fornece várias queries (getBy, findBy, queryBy) que ajudam a encontrar elementos de forma semântica.",
        "code": [
          {
            "description": "Exemplo 1: Teste básico de componente",
            "javascript": "import { render, screen, fireEvent } from '@testing-library/react';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  test('incrementa o contador quando o botão é clicado', () => {\n    render(<Counter />);\n    \n    // Encontra o elemento de texto\n    const countDisplay = screen.getByText(/contagem: 0/i);\n    expect(countDisplay).toBeInTheDocument();\n    \n    // Encontra e clica no botão\n    const button = screen.getByRole('button', { name: /incrementar/i });\n    fireEvent.click(button);\n    \n    // Verifica se o contador foi incrementado\n    expect(screen.getByText(/contagem: 1/i)).toBeInTheDocument();\n  });\n});\n\n// Componente Counter\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Contagem: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Incrementar\n      </button>\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Teste de formulário com validação",
            "javascript": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  test('mostra mensagem de erro com credenciais inválidas', async () => {\n    const mockLogin = jest.fn();\n    render(<LoginForm onLogin={mockLogin} />);\n    \n    // Preenche o formulário\n    fireEvent.change(screen.getByLabelText(/email/i), {\n      target: { value: 'email@invalido.com' }\n    });\n    fireEvent.change(screen.getByLabelText(/senha/i), {\n      target: { value: 'senha123' }\n    });\n    \n    // Submete o formulário\n    fireEvent.click(screen.getByRole('button', { name: /entrar/i }));\n    \n    // Verifica se a mensagem de erro aparece\n    await waitFor(() => {\n      expect(screen.getByText(/credenciais inválidas/i)).toBeInTheDocument();\n    });\n    \n    // Verifica se a função de login não foi chamada\n    expect(mockLogin).not.toHaveBeenCalled();\n  });\n});\n\n// Componente LoginForm\nfunction LoginForm({ onLogin }) {\n  const [error, setError] = useState('');\n  const [formData, setFormData] = useState({ email: '', password: '' });\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      await onLogin(formData);\n    } catch (err) {\n      setError('Credenciais inválidas');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          value={formData.email}\n          onChange={e => setFormData({ ...formData, email: e.target.value })}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Senha:</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={formData.password}\n          onChange={e => setFormData({ ...formData, password: e.target.value })}\n        />\n      </div>\n      {error && <p className=\"error\">{error}</p>}\n      <button type=\"submit\">Entrar</button>\n    </form>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "state-management",
    "arrayId": "array-react-state-management",
    "posts": [
      {
        "id": "1",
        "title": "Gerenciamento de Estado no React",
        "content1": "O gerenciamento de estado é um aspecto crucial no desenvolvimento de aplicações React, especialmente em aplicações maiores e mais complexas. Existem várias soluções disponíveis para gerenciar o estado global da aplicação, cada uma com suas próprias características e casos de uso. As soluções mais populares incluem Redux, Context API, Zustand, Recoil e Jotai.",
        "content2": "O Redux é uma das soluções mais tradicionais e robustas, oferecendo um fluxo de dados unidirecional, um store centralizado e ferramentas poderosas para debugging. A Context API, por outro lado, é uma solução nativa do React que é mais simples e adequada para estados globais que não mudam frequentemente. Bibliotecas mais recentes como Zustand e Recoil oferecem uma API mais simples e melhor performance.",
        "content3": "Ao escolher uma solução de gerenciamento de estado, é importante considerar fatores como a complexidade da aplicação, a frequência de atualizações do estado, a necessidade de ferramentas de debugging, e a curva de aprendizado da equipe. Em muitos casos, uma combinação de diferentes soluções pode ser a melhor abordagem, usando Context API para temas e configurações, e Redux ou Zustand para estados mais complexos.",
        "code": [
          {
            "description": "Exemplo 1: Gerenciamento de estado com Redux",
            "javascript": "import { createSlice, configureStore } from '@reduxjs/toolkit';\n\n// Slice do Redux\nconst todoSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    addTodo: (state, action) => {\n      state.push({\n        id: Date.now(),\n        text: action.payload,\n        completed: false\n      });\n    },\n    toggleTodo: (state, action) => {\n      const todo = state.find(todo => todo.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    }\n  }\n});\n\n// Store do Redux\nconst store = configureStore({\n  reducer: {\n    todos: todoSlice.reducer\n  }\n});\n\n// Componente usando Redux\nfunction TodoApp() {\n  const todos = useSelector(state => state.todos);\n  const dispatch = useDispatch();\n\n  const handleAddTodo = (text) => {\n    dispatch(addTodo(text));\n  };\n\n  return (\n    <div>\n      <AddTodo onAdd={handleAddTodo} />\n      <TodoList todos={todos} />\n    </div>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Gerenciamento de estado com Zustand",
            "javascript": "import create from 'zustand';\n\n// Store do Zustand\nconst useStore = create((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  reset: () => set({ count: 0 })\n}));\n\n// Componente usando Zustand\nfunction Counter() {\n  const { count, increment, decrement, reset } = useStore();\n\n  return (\n    <div>\n      <h2>Contador: {count}</h2>\n      <button onClick={increment}>Incrementar</button>\n      <button onClick={decrement}>Decrementar</button>\n      <button onClick={reset}>Resetar</button>\n    </div>\n  );\n}\n\n// Exemplo de store mais complexo\nconst useAuthStore = create((set) => ({\n  user: null,\n  isAuthenticated: false,\n  login: async (credentials) => {\n    try {\n      const user = await loginAPI(credentials);\n      set({ user, isAuthenticated: true });\n    } catch (error) {\n      console.error('Erro no login:', error);\n    }\n  },\n  logout: () => set({ user: null, isAuthenticated: false })\n}));"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "custom-hooks",
    "arrayId": "array-react-custom-hooks",
    "posts": [
      {
        "id": "1",
        "title": "Custom Hooks no React",
        "content1": "Custom Hooks são funções JavaScript que começam com 'use' e permitem extrair lógica de componentes para funções reutilizáveis. Eles são uma forma poderosa de compartilhar lógica entre componentes, seguindo o princípio DRY (Don't Repeat Yourself) e mantendo o código mais organizado e manutenível.",
        "content2": "Os Custom Hooks podem encapsular qualquer lógica que use outros hooks do React, como useState, useEffect, useContext, etc. Eles são especialmente úteis para lógica complexa que é usada em múltiplos componentes, como gerenciamento de formulários, chamadas de API, subscrições a eventos, e manipulação de estado local.",
        "content3": "Ao criar Custom Hooks, é importante seguir algumas convenções: sempre começar o nome com 'use', manter a lógica focada em uma única responsabilidade, e documentar claramente os parâmetros e retornos. Além disso, é importante considerar a performance e evitar recriações desnecessárias de funções ou valores.",
        "code": [
          {
            "description": "Exemplo 1: Custom Hook para formulário",
            "javascript": "function useForm(initialValues = {}, validate = () => ({})) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const handleChange = useCallback((e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({\n      ...prev,\n      [name]: value\n    }));\n  }, []);\n\n  const handleSubmit = useCallback(async (onSubmit) => {\n    setIsSubmitting(true);\n    const validationErrors = validate(values);\n    setErrors(validationErrors);\n\n    if (Object.keys(validationErrors).length === 0) {\n      await onSubmit(values);\n    }\n    setIsSubmitting(false);\n  }, [values, validate]);\n\n  return {\n    values,\n    errors,\n    isSubmitting,\n    handleChange,\n    handleSubmit\n  };\n}\n\n// Uso do hook\nfunction LoginForm() {\n  const validate = (values) => {\n    const errors = {};\n    if (!values.email) errors.email = 'Email é obrigatório';\n    if (!values.password) errors.password = 'Senha é obrigatória';\n    return errors;\n  };\n\n  const { values, errors, isSubmitting, handleChange, handleSubmit } = useForm(\n    { email: '', password: '' },\n    validate\n  );\n\n  const onSubmit = async (values) => {\n    // Lógica de login\n    console.log('Login com:', values);\n  };\n\n  return (\n    <form onSubmit={(e) => {\n      e.preventDefault();\n      handleSubmit(onSubmit);\n    }}>\n      <input\n        name=\"email\"\n        value={values.email}\n        onChange={handleChange}\n      />\n      {errors.email && <span>{errors.email}</span>}\n      <input\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n      />\n      {errors.password && <span>{errors.password}</span>}\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Enviando...' : 'Entrar'}\n      </button>\n    </form>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Custom Hook para chamadas de API",
            "javascript": "function useApi(endpoint, options = {}) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(endpoint, options);\n        const json = await response.json();\n\n        if (isMounted) {\n          setData(json);\n          setError(null);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err);\n          setData(null);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [endpoint, JSON.stringify(options)]);\n\n  return { data, loading, error };\n}\n\n// Uso do hook\nfunction UserProfile({ userId }) {\n  const { data: user, loading, error } = useApi(`/api/users/${userId}`);\n\n  if (loading) return <div>Carregando...</div>;\n  if (error) return <div>Erro ao carregar usuário</div>;\n  if (!user) return <div>Usuário não encontrado</div>;\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}"
          }
        ]
      }
    ]
  },
  {
    "conceptId": "error-boundaries",
    "arrayId": "array-react-error-boundaries",
    "posts": [
      {
        "id": "1",
        "title": "Error Boundaries no React",
        "content1": "Error Boundaries são componentes React que capturam erros JavaScript em qualquer parte da árvore de componentes filhos, registram esses erros e exibem uma UI de fallback. Elas são uma forma de implementar o padrão de tratamento de erros em React, similar ao bloco try-catch em JavaScript.",
        "content2": "As Error Boundaries são componentes de classe que implementam os métodos de ciclo de vida static getDerivedStateFromError() e componentDidCatch(). O primeiro é usado para renderizar uma UI de fallback quando ocorre um erro, e o segundo é usado para registrar informações sobre o erro. É importante notar que as Error Boundaries não capturam erros em manipuladores de eventos, código assíncrono, renderização do servidor e erros lançados pela própria Error Boundary.",
        "content3": "É uma boa prática implementar Error Boundaries em diferentes níveis da aplicação, com diferentes estratégias de recuperação. Por exemplo, uma Error Boundary de alto nível pode mostrar uma página de erro genérica, enquanto uma Error Boundary em um componente específico pode tentar recuperar o estado anterior ou mostrar uma versão simplificada do componente.",
        "code": [
          {
            "description": "Exemplo 1: Error Boundary básica",
            "javascript": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Aqui você pode registrar o erro em um serviço de monitoramento\n    console.error('Erro capturado:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-boundary\">\n          <h2>Algo deu errado!</h2>\n          <p>Desculpe, ocorreu um erro inesperado.</p>\n          <button onClick={() => this.setState({ hasError: false })}\n          >\n            Tentar novamente\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Uso da Error Boundary\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}"
          },
          {
            "description": "Exemplo 2: Error Boundary com recuperação de estado",
            "javascript": "class ComponentWithErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      lastValidState: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Salva o último estado válido antes do erro\n    this.setState(prevState => ({\n      lastValidState: prevState.lastValidState || this.props.initialState\n    }));\n\n    // Registra o erro\n    logErrorToService(error, errorInfo);\n  }\n\n  handleReset = () => {\n    this.setState({\n      hasError: false,\n      error: null,\n      lastValidState: null\n    });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-recovery\">\n          <h3>Erro no componente</h3>\n          <p>Ocorreu um erro ao processar os dados.</p>\n          {this.state.lastValidState && (\n            <div>\n              <p>Último estado válido:</p>\n              <pre>{JSON.stringify(this.state.lastValidState, null, 2)}</pre>\n            </div>\n          )}\n          <button onClick={this.handleReset}>Restaurar estado anterior</button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Hook para usar Error Boundary em componentes funcionais\nfunction useErrorBoundary() {\n  const [hasError, setHasError] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const handleError = (error) => {\n      setHasError(true);\n      setError(error);\n    };\n\n    window.addEventListener('error', handleError);\n    return () => window.removeEventListener('error', handleError);\n  }, []);\n\n  return { hasError, error };\n}"
          }
        ]
      }
    ]
  }
]
